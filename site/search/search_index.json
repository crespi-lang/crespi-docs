{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"[WIP] Crespi Lang","text":""},{"location":"feature-parity/","title":"Feature Parity (Interpreter vs Compiler)","text":"<p>This document tracks which Crespi language features are available in the interpreter and in the native compiler. It is intentionally short and practical, so it can guide gap-fixing work.</p> <p>Legend: Yes = implemented, Partial = implemented but incomplete or missing checks, No = not supported.</p>"},{"location":"feature-parity/#core-language-features","title":"Core Language Features","text":"Feature Interpreter Compiler Notes Variables and constants Yes Yes <code>var</code>, <code>let</code>; <code>let</code> enforces immutability for collections Control flow Yes Yes <code>if/else</code>, <code>while</code>, <code>for/in</code>, <code>break</code>, <code>continue</code>, <code>guard</code>, <code>when</code> Functions Yes Yes Named, default params, single-expression syntax Async/await Yes Yes Eager <code>Task</code> values; no scheduler yet Lambdas and closures Yes Yes Capture works Classes and constructors Yes Yes Primary (with <code>var</code>/<code>let</code> modifiers) + secondary constructors Inheritance Yes Yes <code>:</code> syntax Operator overloading Yes Yes All operators in the reference Extensions Yes Yes Swift-style extensions Extension trait conformance Yes Yes Default methods applied; conflicts error Generics (duck-typed) Yes Yes <code>fn [T] name()</code> syntax for functions; <code>Class[T]</code> for classes Pattern matching (<code>when</code>) Yes Yes With <code>default</code> Built-in functions (61) Yes Yes Unified registry Top-level code Yes Yes Compiler synthesizes <code>main()</code> Language packs (keywords/builtins) Yes Yes Normalized in the lexer Traits Yes Yes Conformance checks + default methods applied in interpreter/compiler Multi-file imports Yes Yes Module loading + explicit symbol lists supported Decorators Yes Yes Applied at runtime; functions/classes only Nested classes Yes Yes <code>nested</code> for static, <code>inner</code> for outer instance (<code>__outer</code>; <code>o.Inner()</code> now lowers via runtime helper) Assignment as expression No No Statements only (by design)"},{"location":"feature-parity/#syntax-and-ergonomics","title":"Syntax and Ergonomics","text":"Feature Interpreter Compiler Notes String interpolation Yes Yes <code>$name</code> and <code>${expr}</code> Raw/triple-quoted strings Yes Yes Multiline literals Null coalescing Yes Yes <code>??</code> Ternary operator Yes Yes <code>cond ? a : b</code> Automatic semicolon insertion Yes Yes Lexer inserts semicolons on line breaks Visibility modifiers Yes Yes <code>public</code> default; <code>internal</code> = same directory; <code>private</code> = same file; <code>fileprivate</code> = file-scoped Type annotations (syntax) Yes Yes Parsed on vars/params/returns Type checker (optional) Partial Partial Separate pass; opt-in via <code>--check</code> Qualified imports Yes Yes <code>import</code>, <code>import Module { symbols }</code>, <code>import fn</code>, <code>import class</code>"},{"location":"feature-parity/#operators-and-expressions","title":"Operators and Expressions","text":"Feature Interpreter Compiler Notes Arithmetic operators Yes Yes <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> Comparison operators Yes Yes <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> Equality operators Yes Yes <code>==</code>, <code>!=</code> Logical operators Yes Yes <code>&amp;&amp;</code> (AND), <code>||</code> (OR) Bitwise operators Yes Yes <code>&amp;</code>, <code>|</code>, <code>^</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>~</code> Unary operators Yes Yes <code>-</code>, <code>!</code>, <code>~</code> Membership tests Yes Yes <code>value in collection</code> Compound assignment Yes Yes <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>; also <code>i++</code>, <code>i--</code> as statements Indexing and assignment Yes Yes <code>obj[i]</code>, <code>obj[i] = v</code> Property access Yes Yes <code>obj.field</code>, <code>obj.method()</code> Function calls Yes Yes <code>f(x)</code> and <code>operator invoke</code>"},{"location":"feature-parity/#data-types-and-literals","title":"Data Types and Literals","text":"Feature Interpreter Compiler Notes Integers, floats, booleans, null Yes Yes <code>int</code>, <code>float</code>, <code>bool</code>, <code>null</code> Strings Yes Yes UTF-8 text values Lists Yes Yes Literals, indexing, iteration Dictionaries Yes Yes Text-keyed maps Tuples Yes Yes Tuple literals <code>(a, b)</code> Class instances Yes Yes Constructed by calling the class Pattern destructuring Yes Yes Lists/dicts/classes inside <code>when</code>"},{"location":"feature-parity/#functional-and-runtime-behavior","title":"Functional and Runtime Behavior","text":"Feature Interpreter Compiler Notes Higher-order functions Yes Yes Functions as values; extension function types (<code>String.() -&gt; Int</code>) Memoization Yes Yes <code>@memoize</code> and <code>memoize()</code> Tail-call optimization Yes Yes Tail recursion optimized String/list/collection helpers Yes Yes Built-in functions (map/filter/etc.)"},{"location":"feature-parity/#modules-and-resolution","title":"Modules and Resolution","text":"Feature Interpreter Compiler Notes Module imports Yes Yes <code>import Foo.Bar</code> with optional <code>{ symbols }</code> Symbol-specific imports Yes Yes <code>import fn</code>, <code>import class</code>, <code>import Module { symbols }</code> Module path resolution Yes Yes Relative, root, and <code>-I</code> paths; snake_case \u2192 PascalCase Module cycles Yes Yes Tarjan SCC detection for init cycles"},{"location":"feature-parity/#visibility-enforcement-lsp-integration","title":"Visibility Enforcement &amp; LSP Integration","text":"<p>Crespi ensures that <code>public</code>, <code>internal</code>, and <code>private</code> declarations behave the same no matter whether code runs through the interpreter, the native compiler, or the language server.</p> <ul> <li>The interpreter now runs <code>MultiFileInterpreter::type_check_modules</code> during module loading so visibility failures are reported before execution rather than at runtime. <code>MultiFileInterpreter</code> builds a per-module visibility map and resolves imports with the same <code>internal</code>/<code>private</code> rules exposed to the static type checker, keeping the REPL and scripts consistent with the compiled path.</li> <li>The compiler's module namespace builder mirrors the interpreter's visibility map; HIR lowering (<code>crespi-codegen::lowering</code>) filters symbol exports using the same <code>Visibility</code> helpers before emitting imports, and the LLVM backend/runtime enforces the resulting APIs during execution.</li> <li>The external Language Server (crespi-ide-support) uses the same visibility rules to ensure that hover, completion, and go-to-definition only surface symbols that are visible from the import site.</li> <li>Tests cover interpreter and compiler layers: <code>lang/crates/crespi-core/tests/module_imports.rs</code> validates interpreter visibility enforcement (public/internal/private imports), and <code>lang/crates/crespi-codegen</code> has parity tests for compiler visibility errors.</li> </ul>"},{"location":"feature-parity/#type-system-optional","title":"Type System (Optional)","text":"Feature Interpreter Compiler Notes Type annotations Yes Yes Variables, params, returns Type inference Partial Partial HM-style inference pass; optional, not default Nullable types Partial Partial <code>T?</code> sugar for <code>T | Null</code> in checker Union types Partial Partial <code>T | U</code> in checker Type constraints Partial Partial Numeric/Comparable/Equatable constraints Inheritance-aware assignability Partial Partial Subclass checks in type checker"},{"location":"feature-parity/#tooling-and-platform","title":"Tooling and Platform","text":"Feature Interpreter Compiler Notes CLI REPL Yes No Interpreter-only REPL and file runner VSCode extension Yes Yes External (crespi-ide-support repo) LSP diagnostics Partial (visibility-aware) Partial (visibility-aware) External (crespi-ide-support repo). Supports diagnostics, hover, go-to-definition, and completions. WASM execution (web) Yes No External (crespi-wasm repo) Language packs Yes Yes Built-in Spanish pack; validator supports custom packs"},{"location":"feature-parity/#notes-and-known-gaps","title":"Notes and Known Gaps","text":"<ul> <li>Type checking: optional; only run when explicitly requested (<code>--check</code>).</li> <li>Concurrency runtime: async/await tasks are eager today; no scheduler, threads, or actors yet.</li> <li>Assignment expressions: not supported (statements only, by design).</li> </ul>"},{"location":"feature-parity/#verification-checklist","title":"Verification Checklist","text":"<p>These commands help validate the table above:</p> <pre><code># Interpreter + compiler behavior parity for examples\n./scripts/compare-outputs.sh\n# Includes multi_file entrypoint examples.\n\n# Core interpreter tests\ncd lang\ncargo test -p crespi-core\n\n# Visibility enforcement and module imports (interpreter + compiler)\ncargo test -p crespi-core module_imports\ncargo test -p crespi-codegen --lib\n\n# Language pack validation\ncargo run -p crespi-langpack -- validate crates/crespi-i18n/packs/spanish.crespilang</code></pre>"},{"location":"feature-parity/#work-items-current-gaps","title":"Work Items (Current Gaps)","text":"<ul> <li>Assignment expressions (by design)</li> </ul>"},{"location":"feature-parity/#subsystem-coverage-matrix","title":"Subsystem Coverage Matrix","text":"<p>Each layer\u2014interpreter and compiler\u2014now shares the same visibility predicate. This section maps the visibility story to the files/tests that keep the systems aligned.</p>"},{"location":"feature-parity/#interpreter-pipeline","title":"Interpreter Pipeline","text":"<ul> <li>Entry point: <code>lang/crates/crespi-core/src/interpreter/multi_file.rs</code> (<code>MultiFileInterpreter::type_check_modules</code>, <code>module_visibility_map</code>, and <code>is_visible</code>) builds the per-module visibility map before execution.</li> <li>The REPL and script runner use the map for symbol lookup, so private/internal symbols raise errors before runtime.</li> <li>Coverage: <code>cargo test -p crespi-core module_imports</code> exercises public/internal/private imports and qualified access.</li> </ul>"},{"location":"feature-parity/#compiler-pipeline","title":"Compiler Pipeline","text":"<ul> <li>The lowering phase (<code>lang/crates/crespi-codegen/src/lowering.rs</code>) mirrors the interpreter visibility map when collecting namespace exports and resolving imports.</li> <li>Compiler visibility tests in <code>lang/crates/crespi-codegen/src/lib.rs</code> assert the same private/internal restrictions.</li> <li>Coverage: <code>cargo test -p crespi-codegen --lib</code> runs visibility-focused and namespace-resolution tests, ensuring runtime/compile-time agreement.</li> </ul>"},{"location":"feature-parity/#appendix-full-feature-inventory","title":"Appendix: Full Feature Inventory","text":"<p>This appendix enumerates the full language surface to keep the parity table honest.</p>"},{"location":"feature-parity/#syntax-summary","title":"Syntax Summary","text":"<ul> <li>Declarations: <code>var</code>, <code>let</code>, <code>fn</code>, <code>async fn</code>, <code>class</code>, <code>trait</code>, <code>extension</code>, <code>import</code>, visibility modifiers (<code>public</code>, <code>private</code>, <code>internal</code>).</li> <li>Statements: <code>return</code>, <code>break</code>, <code>continue</code>, <code>if/else</code>, <code>while</code>, <code>for/in</code>, <code>guard</code>, <code>when</code>.</li> <li>Expressions: literals, arithmetic/comparison/logical ops, <code>?:</code>, <code>??</code>, <code>await</code>, calls, indexing, property access, lambdas (<code>=&gt;</code>), assignment, class instantiation by call.</li> <li>Patterns: list <code>[a, b]</code>, dictionary <code>{\"name\": n}</code>, class destructuring <code>Person { name: n }</code>.</li> </ul>"},{"location":"feature-parity/#keywords-canonical-spanish-alias","title":"Keywords (Canonical + Spanish Alias)","text":"Category English Spanish Alias Notes Declaration <code>var</code> <code>variable</code> Mutable variable Declaration <code>let</code> <code>immutable</code> Immutable constant Declaration <code>public</code> <code>publico</code> Visibility modifier Declaration <code>private</code> <code>privado</code> Visibility modifier Declaration <code>internal</code> <code>interno</code> Visibility modifier Functions <code>fn</code> <code>bloque</code> Function declaration Functions <code>async</code> <code>asincrono</code> Async function modifier Functions <code>await</code> <code>esperar</code> Await task value Functions <code>return</code> <code>resultado</code> Return from function Control <code>if</code> <code>si</code> Conditional Control <code>else</code> <code>o</code> Conditional branch Control <code>while</code> <code>mientras</code> Loop Control <code>for</code> <code>repetir</code> For-each Control <code>in</code> <code>en</code> Membership / iteration Control <code>break</code> <code>salir</code> Exit loop Control <code>continue</code> <code>continuar</code> Next iteration Control <code>guard</code> <code>asegura</code> Guard clause Control <code>when</code> <code>cuando</code> Pattern matching Control <code>is</code> <code>es</code> <code>when</code> branch Control <code>default</code> <code>defecto</code> <code>when</code> fallback OOP <code>class</code> <code>tipo</code> Class declaration OOP <code>nested</code> <code>anidado</code> Nested class declaration OOP <code>inner</code> <code>interno</code> Inner class declaration OOP <code>trait</code> <code>trait</code> Trait declaration OOP <code>extends</code> <code>extiende</code> Reserved (use <code>:</code>) OOP <code>implements</code> <code>implementa</code> Reserved (use <code>:</code>) OOP <code>this</code> <code>yo</code> Current instance OOP <code>super</code> <code>super</code> Superclass OOP <code>operator</code> <code>operador</code> Operator overloads Modules <code>import</code> <code>importar</code> Imports Modules <code>extension</code> <code>extension</code> Type extensions Literals <code>true</code> <code>verdadero</code> Boolean literal Literals <code>false</code> <code>falso</code> Boolean literal Literals <code>null</code> / <code>nil</code> <code>nada</code> Null literal Logical <code>and</code> <code>and</code> Logical AND Logical <code>or</code> <code>or</code> Logical OR"},{"location":"feature-parity/#operators-and-text-aliases","title":"Operators and Text Aliases","text":"Operator Description Spanish Alias <code>+</code> Add <code>mas</code> <code>-</code> Subtract <code>menos</code> <code>*</code> Multiply <code>por</code> <code>/</code> Divide <code>entre</code> <code>%</code> Modulo <code>modulo</code> <code>&lt;</code> Less than <code>menorQue</code> <code>&gt;</code> Greater than <code>mayorQue</code> <code>&lt;=</code> Less or equal <code>menorOIgual</code> <code>&gt;=</code> Greater or equal <code>mayorOIgual</code> <code>==</code> Equal <code>igualA</code> <code>!=</code> Not equal <code>diferenteDe</code> <code>and</code> / <code>&amp;&amp;</code> Logical AND <code>and</code> <code>or</code> / <code>||</code> Logical OR <code>or</code> <code>??</code> Null coalescing (symbol only) <code>?:</code> Ternary (symbol only)"},{"location":"feature-parity/#operator-overloads-class-level","title":"Operator Overloads (Class Level)","text":"<p>Supported overloads: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>==</code>, <code>!</code>, <code>negate</code>, <code>compare</code>, <code>not</code>, <code>increment</code>, <code>decrement</code>, <code>get</code>, <code>set</code>, <code>contains</code>, <code>invoke</code>.</p>"},{"location":"feature-parity/#built-in-functions-60","title":"Built-in Functions (60)","text":"<p>Aliases in parentheses refer to the Spanish language pack or English aliases.</p> <p>I/O and type conversion - <code>print</code> (<code>mostrar</code>) - <code>read</code> (<code>leer</code>) - <code>typeof</code> (<code>tipo_de</code>, alias <code>type_of</code>) - <code>str</code> (<code>texto</code>, alias <code>string</code>) - <code>int</code> (<code>entero</code>) - <code>float</code> (<code>decimal</code>)</p> <p>Collections (base) - <code>length</code> (<code>longitud</code>, alias <code>len</code>) - <code>push</code> (<code>agregar</code>, alias <code>append</code>) - <code>pop</code> (<code>quitar</code>) - <code>keys</code> (<code>claves</code>) - <code>values</code> (<code>valores</code>) - <code>contains</code> (<code>contiene</code>)</p> <p>Memoization - <code>memoize</code> (<code>memorizar</code>)</p> <p>Strings - <code>split</code> (<code>dividir</code>) - <code>trim</code> (<code>recortar</code>) - <code>uppercase</code> (<code>mayusculas</code>) - <code>lowercase</code> (<code>minusculas</code>) - <code>substring</code> (<code>subcadena</code>) - <code>replace</code> (<code>reemplazar</code>) - <code>starts_with</code> (<code>empieza_con</code>) - <code>ends_with</code> (<code>termina_con</code>) - <code>index_of</code> (<code>indice_de</code>) - <code>join</code> (<code>unir</code>)</p> <p>Collections (functional) - <code>map</code> (<code>mapear</code>) - <code>filter</code> (<code>filtrar</code>) - <code>reduce</code> (<code>reducir</code>) - <code>sort</code> (<code>ordenar</code>) - <code>reverse</code> (<code>invertir</code>) - <code>slice</code> (<code>cortar</code>) - <code>find</code> (<code>encontrar</code>) - <code>every</code> (<code>cada</code>) - <code>some</code> (<code>alguno</code>) - <code>flatten</code> (<code>aplanar</code>)</p> <p>Math - <code>abs</code> (<code>absoluto</code>) - <code>sign</code> (<code>signo</code>) - <code>sqrt</code> (<code>raiz</code>) - <code>cbrt</code> (<code>raiz_cubica</code>) - <code>pow</code> (<code>potencia</code>) - <code>round</code> (<code>redondear</code>) - <code>floor</code> (<code>piso</code>) - <code>ceil</code> (<code>techo</code>) - <code>truncate</code> (<code>truncar</code>) - <code>min</code> (<code>minimo</code>) - <code>max</code> (<code>maximo</code>) - <code>random</code> (<code>aleatorio</code>) - <code>random_seed</code> (<code>semilla_aleatoria</code>) - <code>sin</code> (<code>seno</code>) - <code>cos</code> (<code>coseno</code>) - <code>tan</code> (<code>tangente</code>) - <code>asin</code> (<code>aseno</code>) - <code>acos</code> (<code>acoseno</code>) - <code>atan</code> (<code>atangente</code>) - <code>atan2</code> (<code>atangente2</code>) - <code>exp</code> (<code>exponencial</code>) - <code>ln</code> (<code>logaritmo_natural</code>) - <code>log10</code> (<code>logaritmo10</code>) - <code>log2</code> (<code>logaritmo2</code>) - <code>hypot</code> (<code>hipotenusa</code>) - <code>pi</code> (<code>pi</code>, alias <code>PI</code>) - <code>e</code> (<code>e</code>, alias <code>E</code>)</p> <p>Notes: - <code>PI</code> and <code>E</code> behave as constants in the interpreter. In compiled code, use <code>pi()</code> and <code>e()</code> calls.</p>"},{"location":"feature-parity/#grammar-cheat-sheet-canonical-english","title":"Grammar Cheat Sheet (Canonical English)","text":"<p>Generated from <code>docs/en/reference/grammar.md</code>. Run <code>./scripts/update-feature-parity-grammar.sh</code> to refresh.</p> <pre><code>// Generated from docs/en/reference/grammar.md (parser rules only)\ngrammar Crespi;\n\n// ===== Parser rules =====\n\nprogram\n  : statement* EOF\n  ;\n\nstatement\n  : declaration\n  | ifStmt\n  | whenStmt\n  | whileStmt\n  | forStmt\n  | guardStmt\n  | returnStmt\n  | breakStmt\n  | continueStmt\n  | block\n  | exprStmt\n  ;\n\ndeclaration\n  : importDecl\n  | decorator* visibility? (varDecl | letDecl | functionDecl | extensionFunctionDecl | classDecl | traitDecl)\n  | extensionDecl\n  ;\n\nvisibility\n  : 'public' | 'private' | 'internal' | 'fileprivate'\n  ;\n\ndecorator\n  : '@' IDENTIFIER\n  ;\n\nvarDecl\n  : 'var' IDENTIFIER typeAnn? ('=' expression)? semi\n  ;\n\nletDecl\n  : 'let' IDENTIFIER typeAnn? '=' expression semi\n  ;\n\nfunctionDecl\n  : 'fn' IDENTIFIER typeParams? '(' parameters? ')' returnType? (block | '=' expression semi)\n  ;\n\nextensionFunctionDecl\n  : 'fn' IDENTIFIER '.' IDENTIFIER typeParams? '(' parameters? ')' returnType? (block | '=' expression semi)\n  ;\n\noperatorDecl\n  : 'operator' operatorName '(' parameters? ')' returnType? (block | '=' expression semi)\n  ;\n\nconstructorDecl\n  : 'constructor' '(' parameters? ')' (':' constructorDelegation)? block\n  ;\n\nconstructorDelegation\n  : 'this' '(' arguments? ')'\n  | 'super' '(' arguments? ')'\n  ;\n\nclassDecl\n  : 'class' IDENTIFIER typeParams? ('(' parameters? ')')? (':' parents)? classBody?\n  ;\n\nparents\n  : IDENTIFIER ('(' arguments? ')')? (',' IDENTIFIER)*\n  ;\n\nclassBody\n  : '{' classMember* '}'\n  ;\n\nclassMember\n  : functionDecl\n  | operatorDecl\n  | constructorDecl\n  | varDecl\n  | letDecl\n  | staticMember\n  ;\n\nstaticMember\n  : 'static' functionDecl\n  | 'static' varDecl\n  | 'static' letDecl\n  | 'static' block\n  ;\n\ntraitDecl\n  : 'trait' IDENTIFIER typeParams? (':' parents)? '{' traitMember* '}'\n  ;\n\ntraitMember\n  : 'fn' IDENTIFIER '(' parameters? ')' returnType? block?\n  ;\n\nextensionDecl\n  : 'extension' IDENTIFIER (':' parents)? '{' extensionMember* '}'\n  ;\n\nextensionMember\n  : functionDecl\n  | operatorDecl\n  ;\n\nimportDecl\n  : 'import' importKind? modulePath importAlias? importSymbols? semi\n  ;\n\nimportKind\n  : 'fn' | 'class' | 'let' | 'var'\n  ;\n\nimportAlias\n  : 'as' IDENTIFIER\n  ;\n\nimportSymbols\n  : '{' importSymbol (',' importSymbol)* '}'\n  ;\n\nimportSymbol\n  : IDENTIFIER importAlias?\n  ;\n\nmodulePath\n  : IDENTIFIER ('.' IDENTIFIER)*\n  ;\n\nparameters\n  : parameter (',' parameter)*\n  ;\n\nparameter\n  : IDENTIFIER typeAnn? ('=' expression)?\n  ;\n\ntypeParams\n  : '[' typeParam (',' typeParam)* ']'\n  ;\n\ntypeParam\n  : IDENTIFIER (':' typeExpr)?\n  ;\n\ntypeAnn\n  : ':' typeExpr\n  ;\n\nreturnType\n  : '-&gt;' typeExpr\n  ;\n\nifStmt\n  : 'if' expression block ('else' (ifStmt | block))?\n  ;\n\nguardStmt\n  : 'guard' (guardBind | expression) 'else' blockExpr semi?\n  ;\n\nguardBind\n  : 'var' IDENTIFIER '=' expression\n  ;\n\nwhenStmt\n  : 'when' expression '{' whenCase* defaultCase? '}'\n  ;\n\nwhenCase\n  : 'is' pattern '=&gt;' block\n  ;\n\ndefaultCase\n  : 'default' '=&gt;' block\n  ;\n\nwhileStmt\n  : 'while' expression block\n  ;\n\nforStmt\n  : 'for' IDENTIFIER 'in' expression block\n  ;\n\nreturnStmt\n  : 'return' expression? semi\n  ;\n\nbreakStmt\n  : 'break' semi\n  ;\n\ncontinueStmt\n  : 'continue' semi\n  ;\n\nexprStmt\n  : expression semi\n  ;\n\nblock\n  : '{' statement* '}'\n  ;\n\nblockExpr\n  : '{' statement* blockExprTail? '}'\n  ;\n\nblockExprTail\n  : 'return' expression?\n  | expression\n  ;\n\nexpression\n  : assignment\n  ;\n\nassignment\n  : conditional (assignmentOp assignment)?\n  ;\n\nassignmentOp\n  : '=' | '+=' | '-=' | '*=' | '/='\n  ;\n\nconditional\n  : ifExpr\n  | coalesce ('?' expression ':' expression)?\n  ;\n\nifExpr\n  : 'if' expression blockExpr 'else' blockExpr\n  ;\n\ncoalesce\n  : logicalOr ('??' logicalOr)*\n  ;\n\nlogicalOr\n  : logicalAnd (('or' | '||') logicalAnd)*\n  ;\n\nlogicalAnd\n  : bitwiseOr (('and' | '&amp;&amp;') bitwiseOr)*\n  ;\n\nbitwiseOr\n  : bitwiseXor ('|' bitwiseXor)*\n  ;\n\nbitwiseXor\n  : bitwiseAnd ('^' bitwiseAnd)*\n  ;\n\nbitwiseAnd\n  : equality ('&amp;' bitwiseAnd)*\n  ;\n\nequality\n  : comparison (('==' | '!=') comparison)*\n  ;\n\ncomparison\n  : shift (('&lt;' | '&lt;=' | '&gt;' | '&gt;=' | 'in') shift)*\n  ;\n\nshift\n  : term (('&lt;&lt;' | '&gt;&gt;') term)*\n  ;\n\nterm\n  : factor (('+' | '-') factor)*\n  ;\n\nfactor\n  : unary (('*' | '/' | '%') unary)*\n  ;\n\nunary\n  : ('!' | '-' | '~') unary\n  | call\n  ;\n\ncall\n  : primary callSuffix*\n  ;\n\ncallSuffix\n  : '(' arguments? ')'\n  | '.' IDENTIFIER\n  | '[' expression ']'\n  | '++'\n  | '--'\n  ;\n\narguments\n  : expression (',' expression)*\n  ;\n\nprimary\n  : literal\n  | IDENTIFIER\n  | 'this'\n  | 'super' '.' IDENTIFIER\n  | lambdaExpr\n  | tupleLiteral\n  | '(' expression ')'\n  | arrayLiteral\n  | dictLiteral\n  ;\n\nlambdaExpr\n  : IDENTIFIER '=&gt;' lambdaBody\n  | '(' parameters? ')' returnType? '=&gt;' lambdaBody\n  ;\n\nlambdaBody\n  : block\n  | expression\n  ;\n\ntupleLiteral\n  : '(' expression ',' (expression (',' expression)*)? ','? ')'\n  ;\n\narrayLiteral\n  : '[' (expression (',' expression)*)? ']'\n  ;\n\ndictLiteral\n  : '{' (dictEntry (',' dictEntry)*)? '}'\n  ;\n\ndictEntry\n  : (IDENTIFIER | STRING) ':' expression\n  ;\n\npattern\n  : '_'\n  | IDENTIFIER patternClass?\n  | literal\n  | listPattern\n  | dictPattern\n  ;\n\npatternClass\n  : '{' patternField (',' patternField)* '}'\n  ;\n\npatternField\n  : IDENTIFIER ':' pattern\n  ;\n\nlistPattern\n  : '[' (pattern (',' pattern)*)? ']'\n  ;\n\ndictPattern\n  : '{' (patternEntry (',' patternEntry)*)? '}'\n  ;\n\npatternEntry\n  : (IDENTIFIER | STRING) ':' pattern\n  ;\n\noperatorName\n  : '+' | '-' | '*' | '/' | '%'\n  | '==' | '!' | '&lt;' | '&lt;=&gt;'\n  | 'compare' | 'negate' | 'not'\n  | 'increment' | 'decrement'\n  | 'get' | 'set' | 'contains' | 'invoke'\n  ;\n\ntypeExpr\n  : unionType\n  ;\n\nunionType\n  : nullableType ('|' nullableType)*\n  ;\n\nnullableType\n  : primaryType '?'?\n  ;\n\nprimaryType\n  : arrayType\n  | dictType\n  | functionType\n  | tupleType\n  | namedType\n  ;\n\nnamedType\n  : IDENTIFIER ('[' typeExpr (',' typeExpr)* ']')? ('.' '(' parameters? ')' '-&gt;' typeExpr)?\n  ;\n\narrayType\n  : '[' typeExpr ']'\n  ;\n\ndictType\n  : '{' typeExpr ':' typeExpr '}'\n  ;\n\nfunctionType\n  : '(' typeExpr (',' typeExpr)* ')' '-&gt;' typeExpr\n  ;\n\ntupleType\n  : '(' typeExpr (',' typeExpr)+ ')'\n  ;\n\nsemi\n  : ';'?\n  ;\n</code></pre>"},{"location":"language-comparison/","title":"Crespi vs. Kotlin vs. Swift: Feature Comparison Report","text":"<p>Crespi is a modern, statically typed language with Hindley-Milner style type inference. It blends the ergonomic syntax of Kotlin with the structural patterns of Swift and the keyword brevity of Rust. It runs on a dual-engine architecture: a tree-walking interpreter for development/scripting and an LLVM-based native compiler for production.</p>"},{"location":"language-comparison/#1-core-syntax-keywords","title":"1. Core Syntax &amp; Keywords","text":"Feature Crespi Kotlin Swift Analysis Function Decl <code>fn name(arg: T) -&gt; T</code> <code>fun name(arg: T): T</code> <code>func name(_ arg: T) -&gt; T</code> Crespi uses Rust-style <code>fn</code> and <code>-&gt;</code> but follows Kotlin's simplicity (no argument labels). Variables <code>var</code> (mut), <code>let</code> (immut) <code>var</code> (mut), <code>val</code> (immut) <code>var</code> (mut), <code>let</code> (immut) Crespi matches Swift's <code>let</code> for immutability. Generics <code>List[T]</code> (Square brackets) <code>List&lt;T&gt;</code> (Angle brackets) <code>List&lt;T&gt;</code> (Angle brackets) Crespi uses <code>[]</code> for generics (like Python/Scala) to avoid parser ambiguities. Constructors <code>class Point(var x, let y)</code> <code>class Point(val x, val y)</code> <code>init(x: y:)</code> Crespi follows Kotlin's \"Primary Constructor\" pattern with explicit <code>var</code>/<code>let</code> modifiers for properties. Extensions <code>extension Type { ... }</code> or <code>fn Type.name()</code> <code>fun Type.method() { ... }</code> <code>extension Type { ... }</code> Crespi supports both Swift-style block extensions and Kotlin-style inline extension functions. Extension functions are automatically exposed as plain functions (<code>dual-dispatch</code>). Inheritance <code>class Dog : Animal</code> <code>class Dog : Animal()</code> <code>class Dog : Animal</code> Crespi uses the colon syntax common to both, without the required parens of Kotlin."},{"location":"language-comparison/#2-control-flow-pattern-matching","title":"2. Control Flow &amp; Pattern Matching","text":"Feature Crespi Kotlin Swift Analysis Conditionals <code>if</code>, <code>guard</code> <code>if</code> (expression) <code>if</code>, <code>guard</code> Crespi includes Swift's <code>guard</code> statement, which Kotlin lacks natively (requires <code>?: return</code>). Matching <code>when</code> (expression) <code>when</code> (expression) <code>switch</code> Crespi uses Kotlin's <code>when</code> keyword but supports Swift-like structural destructuring (e.g., <code>is [a, b] =&gt;</code>). Loops <code>for x in list</code>, <code>while</code> <code>for (x in list)</code>, <code>while</code> <code>for x in list</code>, <code>while</code> Identical <code>for..in</code> paradigm across all three. Ranges (In loops via iterators) <code>1..10</code>, <code>1 until 10</code> <code>1...10</code>, <code>1..&lt;10</code> Crespi currently relies on collection iteration; standard ranges are less syntactic."},{"location":"language-comparison/#3-type-system-null-safety","title":"3. Type System &amp; Null Safety","text":"Feature Crespi Kotlin Swift Analysis Typing Static (HM inference) Static (Strong) Static (Strong) Crespi is statically typed with Hindley-Milner style inference. Type annotations are optional due to inference. The interpreter provides relaxed mode (warnings only) for beginners, while the compiler enforces strict type checking. Type Inference Hindley-Milner style Flow-sensitive Bidirectional Crespi's type checker uses constraint-based type inference with type variable unification. Null Safety <code>T?</code>, <code>??</code> (Coalesce) <code>T?</code>, <code>?:</code> (Elvis) <code>T?</code>, <code>??</code> (Coalesce) Crespi uses Swift's <code>??</code> operator instead of Kotlin's <code>?:</code>. Union Types <code>Int \\| String</code> (Smart casts / <code>Any</code>) (Enums / <code>Result</code>) Crespi supports ad-hoc union types (<code>|</code>) natively, a feature neither Kotlin nor Swift has directly (they use sealed classes/enums). Type Aliases <code>type UserId = Int</code> <code>typealias</code> <code>typealias</code> Crespi supports type aliases for semantic clarity without runtime overhead. Immutability <code>let</code> (deep for collections) <code>val</code> (shallow) <code>let</code> (shallow) Crespi enforces stricter immutability: <code>let</code>-bound collections cannot be mutated via <code>.push()</code>, <code>.pop()</code>, etc. Traits/Interfaces <code>trait</code> <code>interface</code> <code>protocol</code> Crespi's <code>trait</code> is functionally equivalent to Kotlin interfaces and Swift protocols (supporting default implementations)."},{"location":"language-comparison/#4-memory-management-runtime","title":"4. Memory Management &amp; Runtime","text":"<p>This is where the languages diverge most significantly.</p> Feature Crespi Kotlin Swift Analysis Strategy RefCounting + Cycle Detection Tracing GC (JVM/Native) ARC (Manual Weak Refs) Crespi occupies a middle ground: deterministic cleanup like Swift, but with automatic cycle handling unlike Swift. Cycle Handling Automatic (Mark-and-Sweep backup) Automatic (Tracing GC) Manual (<code>weak</code>, <code>unowned</code>) Crespi relieves the developer from thinking about reference cycles, a common pain point in Swift. Runtime Overhead Moderate (Ref manipulation + Cycle check) Variable (Stop-the-world potential) Low (Deterministic, but hidden costs) Crespi's runtime is lighter than a JVM but heavier than pure C++ due to the cycle detector. Backing LLVM (AOT) JVM Bytecode / LLVM LLVM Crespi uses LLVM for native codegen. <p>Deep Dive: Crespi's GC approach Crespi implements a Reference Counting system augmented with a Cycle Detector. Every object header tracks its reference count. When a count hits zero, it is freed immediately (like Swift). However, to solve the \"island of isolation\" problem (A points to B, B points to A), Crespi's runtime periodically scans the heap (starting from roots) to detect and reclaim unreachable cyclic graphs. This allows Crespi to support closures and complex data structures without forcing the user to learn <code>weak</code> or <code>unowned</code> semantics.</p>"},{"location":"language-comparison/#5-uniquedistinctive-features","title":"5. Unique/Distinctive Features","text":"<ul> <li>Language Packs (i18n): Crespi has built-in support for localized keywords (e.g., Spanish <code>si</code> instead of <code>if</code>), a feature absent in Kotlin and Swift.</li> <li>Internationalized Extension Targets: Extensions in Crespi can target localized type aliases (e.g., <code>extension Texto { ... }</code> or <code>fn Entero.isOdd()</code>). This allows library authors to write APIs that feel native to the user's language.</li> <li>Dual Engine: Crespi explicitly maintains parity between an Interpreter (for REPL/Web) and a Native Compiler. Kotlin has multiple backends but is primarily compiler-driven; Swift is natively compiled.</li> <li>Decorator System: Crespi supports Python/JS-style decorators (<code>@memoize</code>) natively. Kotlin uses Annotations (<code>@Target</code>) which are metadata, whereas Crespi decorators can wrap behavior at runtime.</li> <li>Ad-Hoc Union Types: <code>fn parse(x) -&gt; Int | Error</code> is a first-class citizen in Crespi. Swift requires <code>enum</code> wrappers; Kotlin requires sealed classes or <code>Any</code>.</li> <li>Static Class Members: Crespi supports <code>static</code> fields, methods, and initialization blocks within classes. Static blocks execute during class definition, enabling complex initialization logic.</li> <li>Extension Functions: Beyond Swift-style <code>extension Type { ... }</code> blocks, Crespi also supports Kotlin-style inline extension functions via <code>fn Type.method()</code> syntax. These are automatically exposed as plain functions for library compatibility (dual-dispatch).</li> </ul>"},{"location":"language-comparison/#6-missing-features-gaps-vs-kotlinswift","title":"6. Missing Features (Gaps vs. Kotlin/Swift)","text":"<ul> <li>Concurrency: Kotlin has Coroutines (suspend functions), Swift has Async/Await (Actors). Crespi now has <code>async</code>/<code>await</code>, but still lacks a true concurrency runtime (scheduler, threads, or actors).</li> <li>Properties: Kotlin and Swift have sophisticated property observers (<code>get</code>/<code>set</code>, <code>willSet</code>, <code>didSet</code>). Crespi has basic fields and methods.</li> <li>Advanced Generics: Swift supports recursive protocol constraints and opaque types (<code>some View</code>). Crespi's generics are currently simpler, focusing on container parameterization.</li> </ul>"},{"location":"language-comparison/#61-recently-added-features","title":"6.1 Recently Added Features","text":"<p>The following features have been added to close gaps with Kotlin/Swift:</p> <ul> <li><code>async</code>/<code>await</code> Syntax: Async functions now return <code>Task</code> values, and <code>await</code> unwraps them (eager execution; no scheduler yet).</li> <li><code>fileprivate</code> Visibility: Swift-style file-scoped visibility modifier now available (<code>fileprivate fn helper()</code>).</li> <li>Increment/Decrement Operators: <code>i++</code> and <code>i--</code> as postfix statement-only operators (equivalent to <code>i += 1</code> and <code>i -= 1</code>).</li> <li>Generic Function Syntax: Type parameters now come after <code>fn</code>: <code>fn [T] identity(x: T) -&gt; T</code> (instead of <code>fn identity[T]()</code>).</li> <li>Primary Constructor Property Modifiers: Explicit <code>var</code>/<code>let</code> required for constructor parameters to become properties: <code>class Point(let x: Int, var y: Int)</code>. Parameters without modifiers are constructor-only arguments.</li> <li>Extension Function Types: Lambda parameter types can specify a receiver: <code>fn apply(block: String.() -&gt; Int)</code> and <code>fn map(transform: T.(Int) -&gt; U)</code>.</li> </ul>"},{"location":"language-comparison/#7-compiler-optimization-roadmap","title":"7. Compiler Optimization Roadmap","text":""},{"location":"language-comparison/#current-state","title":"Current State","text":"<p>Crespi's compiler (<code>crespi-llvm</code>) lowers High-Level IR (HIR) to LLVM IR. The HIR optimizer still handles constant folding, dead code elimination, and inlining (<code>-O1/-O2</code>), while LLVM's pass pipeline will provide low-level optimizations (instruction selection, register allocation, scheduling).</p>"},{"location":"language-comparison/#lessons-from-kotlin-swift","title":"Lessons from Kotlin &amp; Swift","text":"<ul> <li>Swift's SIL (Swift Intermediate Language): Swift uses a high-level IR to perform domain-specific optimizations before lowering to LLVM. Key optimizations include:<ul> <li>Definite Initialization: Ensuring all variables are initialized before use (Crespi does this in the resolver, but could be more robust).</li> <li>ARC Optimization: Removing redundant retain/release pairs. Crespi's cycle detector could benefit from static analysis to elide refcounting for stack-local variables.</li> <li>Generic Specialization: Creating specialized versions of generic functions for specific types to avoid boxing overhead.</li> </ul> </li> <li>Kotlin's Inline Functions: Kotlin aggressively inlines lambdas to avoid allocation overhead. This is crucial for higher-order functions like <code>map</code> and <code>filter</code>.</li> </ul>"},{"location":"language-comparison/#recommended-improvements-for-crespi","title":"Recommended Improvements for Crespi","text":"<ol> <li>HIR Optimization Pass: Introduce or expand transformation passes on the HIR before LLVM lowering.<ul> <li>Constant Folding: Pre-calculate constant expressions (e.g., <code>1 + 2</code> -&gt; <code>3</code>).</li> <li>Dead Code Elimination: Remove unreachable branches early.</li> </ul> </li> <li>Inlining Support: Implement an <code>@inline</code> decorator and logic to substitute function bodies at call sites, specifically for closures used in control flow.</li> <li>Specialized Generics: currently, Crespi generics are duck-typed/erased. Generating specialized machine code for <code>List[Int]</code> vs <code>List[Float]</code> would significantly improve numeric performance.</li> <li>Escape Analysis: Analyze closure captures to allocate environments on the stack instead of the heap when they don't escape the function scope.</li> </ol>"},{"location":"language-comparison/#8-generics-metaprogramming","title":"8. Generics &amp; Metaprogramming","text":""},{"location":"language-comparison/#generics","title":"Generics","text":"<ul> <li>Swift: Highly sophisticated system with conditional conformances (e.g., <code>Array&lt;T&gt;</code> is <code>Equatable</code> only if <code>T</code> is <code>Equatable</code>), recursive protocol constraints, and opaque types (<code>some View</code>). Generics are reified at runtime or specialized at compile time.</li> <li>Kotlin: Supports reified type parameters only in inline functions. Standard generics are erased at runtime (similar to Java), but the frontend (FIR) performs advanced flow-sensitive typing (smart casts).</li> <li>Crespi: Currently uses a \"duck-typed\" generics system. <code>List[T]</code> is syntactically parsed, but <code>T</code> is effectively <code>Any</code> at runtime. The compiler does not yet generate specialized machine code for <code>List[Int]</code> vs <code>List[String]</code>.</li> </ul>"},{"location":"language-comparison/#metaprogramming","title":"Metaprogramming","text":"<ul> <li>Swift: Macros (compiler plugins) allow syntactic transformations at compile time. Property wrappers (<code>@State</code>, <code>@Published</code>) provide behavior injection for fields.</li> <li>Kotlin: Compiler plugins (KSP/Kapt) allow code generation. Delegated properties (<code>by lazy</code>) provide a mechanism similar to Swift's property wrappers but are part of the language core.</li> <li>Crespi: Supports Decorators (<code>@memoize</code>) which are applied at runtime in the interpreter and lowered to wrappers in the compiler. This is closer to Python's dynamic decorators than Swift's macros.</li> </ul>"},{"location":"language-comparison/#9-concurrency","title":"9. Concurrency","text":"<p>This is the most significant functional gap between Crespi and its peers.</p> <ul> <li>Swift: Structured Concurrency. First-class <code>async</code>/<code>await</code> syntax, <code>Task</code> groups, and Actors for data isolation. The runtime manages a thread pool, and the compiler enforces thread safety via <code>Sendable</code> checks.</li> <li>Kotlin: Coroutines. Lightweight threads (suspend functions) that multiplex over system threads. Supports <code>async</code>/<code>await patterns and</code>Flow` for streams.</li> <li>Crespi: Eager async/await (single-threaded).<ul> <li>Current State: <code>async</code>/<code>await</code> is available, but async functions execute immediately and return completed <code>Task</code> values. There is still no scheduler, threads, or actors.</li> <li>Runtime Hooks: The GC implementation (<code>gc.rs</code>) mentions \"atomic reference counting hooks\" for future threading support, but the current <code>GcContext</code> is fundamentally single-threaded.</li> </ul> </li> </ul>"},{"location":"language-comparison/#10-error-handling-diagnostics","title":"10. Error Handling &amp; Diagnostics","text":"Feature Crespi Kotlin Swift Analysis Paradigm Union Types / Result Unchecked Exceptions <code>throws</code> / <code>try</code> (Result-like) Crespi treats errors as values, whereas Kotlin/Swift use more traditional exception models (though Swift's is technically a typed Result sugar). Syntax <code>Int \\| Error</code> <code>throw Exception()</code> <code>throw Error</code>, <code>try</code> Crespi avoids the \"hidden control flow\" of exceptions by making errors part of the return type. Diagnostics i18n-aware (Fluent) English-centric English-centric Crespi is uniquely designed to provide compiler errors in the user's native language."},{"location":"language-comparison/#11-ffi-interoperability","title":"11. FFI &amp; Interoperability","text":"<ul> <li>Swift: Clang Importer. Swift can directly import C and Objective-C headers. The compiler automatically maps C types to Swift types.</li> <li>Kotlin: cinterop (Native) / JNI (JVM). Kotlin/Native uses a tool to generate \"interop klibs\" from C headers.</li> <li>Crespi: Native Runtime Registry + Marshaling Traits.<ul> <li>Runtime Registry: Crespi supports calling Rust-defined functions via a <code>NativeFn</code> registry in the runtime (<code>crespi-runtime</code>). These functions must follow the <code>extern \"C\"</code> ABI.</li> <li>Marshaling Layer: The <code>crespi-ffi</code> crate provides <code>FromCrespi</code> and <code>ToCrespi</code> traits for automatic type conversion between Crespi values and Rust types. Supported types include primitives (<code>i32</code>, <code>i64</code>, <code>f64</code>, <code>bool</code>, <code>String</code>), collections (<code>Vec&lt;T&gt;</code>, <code>HashMap&lt;String, T&gt;</code>), and <code>Option&lt;T&gt;</code>.</li> <li>Native Function Signature: <code>extern \"C\" fn(&amp;mut GcContext, *const CrespiValue, usize) -&gt; CrespiValue</code></li> <li>Multi-Language Vision: The FFI architecture is designed to support additional languages in the future through the C ABI foundation.</li> </ul> </li> </ul>"},{"location":"language-comparison/#12-ecosystem-tooling","title":"12. Ecosystem &amp; Tooling","text":"<ul> <li>Swift: Swift Package Manager (SPM). Integrated into the compiler. Highly mature ecosystem centered around Apple platforms but expanding to Server/Linux.</li> <li>Kotlin: Gradle. Extremely powerful but complex build system. Multiplatform (KMP) support is a major strength.</li> <li>Crespi: Early Stage.<ul> <li>Build System: Currently relies on <code>cargo</code> (for the compiler itself) and simple shell scripts for project management. No native \"Crespi Package Manager\" yet.</li> <li>Standard Library: 60+ built-in functions compiled as a separate static library (<code>crespi-builtins</code>), including math, string manipulation, functional collection methods, and I/O. All functions have English and Spanish aliases.</li> <li>Tooling: Strong VSCode integration via a dedicated LSP in a separate repository (<code>crespi-ide-support</code>), providing hover, go-to-definition, completions, and diagnostic support.</li> <li>Web: First-class WASM support allows the interpreter to run directly in browsers with full IntelliSense (via <code>crespi-wasm</code> repo).</li> </ul> </li> </ul>"},{"location":"language-comparison/#13-reflection-introspection","title":"13. Reflection &amp; Introspection","text":"<ul> <li>Swift: Mirror API. Provides read-only introspection of types and values. Swift also has strong compile-time type information but limited runtime manipulation compared to Java.</li> <li>Kotlin: Full Reflection. Built on JVM reflection, providing deep access to properties, methods, and annotations at runtime.</li> <li>Crespi: Basic Introspection.<ul> <li>Built-in: <code>typeof(x)</code> returns a string representation of the type.</li> <li>Static Typing with Relaxed Mode: Crespi is statically typed with optional annotations (due to HM inference). The interpreter provides a relaxed mode where type errors appear as warnings but execution continues, making it beginner-friendly while maintaining type safety in compiled code.</li> </ul> </li> </ul>"},{"location":"language-comparison/#14-type-system-nuances","title":"14. Type System Nuances","text":""},{"location":"language-comparison/#variance-generics","title":"Variance (Generics)","text":"<ul> <li>Kotlin: Declaration-site variance (<code>out</code>/<code>in</code> keywords).</li> <li>Swift: Uses generics without explicit variance keywords but handles it through subtyping and protocol requirements.</li> <li>Crespi: Implicit/Erased. Crespi does not currently enforce variance. Generics are closer to \"syntax sugar\" for the type checker, and the runtime treats them as <code>Any</code>.</li> </ul>"},{"location":"language-comparison/#enums-vs-union-types","title":"Enums vs. Union Types","text":"<ul> <li>Kotlin/Swift: Heavy reliance on Enums (Sum Types) for modeling state and errors.</li> <li>Crespi: Reliance on Ad-hoc Union Types (<code>A | B</code>). Crespi does not have a formal <code>enum</code> keyword; it achieves the same goals through union types and class hierarchies.</li> </ul>"},{"location":"language-comparison/#15-target-platforms-portability","title":"15. Target Platforms &amp; Portability","text":"Platform Crespi Kotlin Swift Mobile (iOS/Android) No (Planned) Primary (KMP) Primary (iOS) Web (Browser) Yes (External Repo) Yes (JS/WASM) Experimental (WASM) Server/Desktop Yes (Native) Primary (JVM) Primary (Linux/macOS) Embedded No Yes (Native) Yes (Embedded Swift)"},{"location":"language-comparison/#16-philosophy-design-goals","title":"16. Philosophy &amp; Design Goals","text":"<ul> <li>Swift: \"Safe, Fast, Expressive.\" Focuses on performance (LLVM), safety (ARC/Exclusivity), and ABI stability.</li> <li>Kotlin: \"Pragmatic, Concise, Safe.\" Focuses on interoperability (JVM), developer productivity, and multiplatform sharing.</li> <li>Crespi: \"Accessible, Modern, Consistent.\"<ul> <li>i18n first: Breaking the \"English-only\" barrier of programming.</li> <li>Dual Engine: Providing the same language experience for both high-speed native execution and low-overhead scripting/web use.</li> <li>Hybrid Safety: Merging the structural safety of Swift (<code>guard</code>, strict init) with the ergonomic flexibility of Kotlin.</li> </ul> </li> </ul>"},{"location":"language-comparison/#summary","title":"Summary","text":"<p>Crespi positions itself as a \"best-of-breed\" language:</p> <ol> <li>Ergonomics: It takes the concise <code>fn</code> and <code>let</code> from functional languages (Rust/Swift).</li> <li>Structure: It adopts Kotlin's primary constructors and <code>when</code> expression.</li> <li>Safety: It adopts Swift's <code>guard</code> and strict initialization, but automates memory management further than Swift by handling cycles.</li> <li>Innovation: It adds native Union Types, Language Packs, and Internationalized Extensions, differentiating it from its predecessors.</li> </ol> <p>Crespi is less mature regarding concurrency and memory model tooling compared to the battle-tested JVM (Kotlin) or ARC (Swift) ecosystems, but its syntax is a modern, cohesive blend of both.</p>"},{"location":"en/","title":"Crespi - Documentation","text":"<p>Language: Espanol | English</p> <p>Crespi is a multilingual programming language (via language packs) with English as the primary syntax and Spanish available as the first language pack, designed to make programming more accessible to Spanish speakers and other language communities.</p>"},{"location":"en/#type-system","title":"Type System","text":"<p>Crespi is statically typed with Hindley-Milner style type inference. Type annotations are optional because the type checker can infer types from context. The language provides two execution modes with different strictness levels:</p> <ul> <li>Compiler (<code>crespic</code>): Strict mode - type errors block compilation</li> <li>Interpreter (<code>crespi</code>): Relaxed mode - type errors appear as warnings, execution continues</li> </ul> <p>This dual approach allows beginners to learn incrementally while ensuring production code is type-safe.</p>"},{"location":"en/#contents","title":"Contents","text":""},{"location":"en/#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start - Your first program in Crespi</li> </ul>"},{"location":"en/#language-reference","title":"Language Reference","text":"<ul> <li>Keywords - All reserved words</li> <li>Operators - Arithmetic, comparison, and logical operators</li> <li>Built-in Functions - Default available functions</li> <li>Data Types - Crespi's type system</li> <li>Grammar (ANTLR4) - Reference grammar</li> </ul>"},{"location":"en/#execution","title":"Execution","text":"<ul> <li>Interpreter - Run code directly</li> <li>Compiler - Compile to native executable</li> <li>Feature Parity - Interpreter vs compiler support matrix</li> </ul>"},{"location":"en/#architecture","title":"Architecture","text":"<ul> <li>Overview - High-level architecture</li> <li>Crate Structure - Rust crate organization</li> </ul>"},{"location":"en/#contributing","title":"Contributing","text":"<ul> <li>Contributing Guide - How to contribute</li> <li>Code Style - Coding standards</li> </ul>"},{"location":"en/#language-guide","title":"Language Guide","text":"<ul> <li>Variables and Constants</li> <li>Control Flow</li> <li>Functions</li> <li>Lists and Dictionaries</li> <li>Classes and Objects</li> <li>Advanced Features</li> </ul>"},{"location":"en/#key-features","title":"Key Features","text":""},{"location":"en/#multilingual-syntax","title":"Multilingual Syntax","text":"<p>English is canonical; language packs provide localized aliases. Spanish is the first language pack, with the architecture designed to support additional languages in the future. See the Spanish docs for localized examples.</p> <pre><code>// English (primary)\nvar name = \"Ana\"\nlet PI = 3.14159\n\nif name == \"Ana\" {\n    print(\"Hello, Ana!\")\n}</code></pre>"},{"location":"en/#readable-operators","title":"Readable Operators","text":"<p>Crespi allows using operators in symbolic or textual form:</p> <pre><code>// Symbolic form\nvar sum = 5 + 3\n\n// Textual form (Spanish operators)\nvar sumText = 5 mas 3</code></pre>"},{"location":"en/#object-oriented-programming","title":"Object-Oriented Programming","text":"<pre><code>class Person(let name, let age) {\n    fn greet() {\n        print(\"Hello, I'm \" + this.name)\n    }\n}\n\nvar ana = Person(\"Ana\", 25)\nana.greet()</code></pre>"},{"location":"en/#first-class-functions","title":"First-Class Functions","text":"<pre><code>fn double(x) {\n    return x * 2\n}\n\nfn apply(func, value) {\n    return func(value)\n}\n\nprint(apply(double, 5))  // 10</code></pre>"},{"location":"en/#installation","title":"Installation","text":""},{"location":"en/#requirements","title":"Requirements","text":"<ul> <li>Rust 1.70+</li> <li>Cargo</li> </ul>"},{"location":"en/#build-from-source","title":"Build from Source","text":"<pre><code>git clone https://github.com/user/crespi-lang.git\ncd crespi-lang\ncargo build --release</code></pre>"},{"location":"en/#run","title":"Run","text":"<pre><code># Interactive REPL\ncargo run\n\n# Run a file\ncargo run -- program.crespi</code></pre>"},{"location":"en/#resources","title":"Resources","text":"<ul> <li>Examples - Example programs</li> <li>IDE Support - VS Code extension and LSP</li> <li>WASM Runtime - WebAssembly bindings</li> <li>Web Platform - Learn in the browser</li> </ul>"},{"location":"en/quick-start/","title":"Quick Start","text":"<p>Language: Espa\u00f1ol | English</p> <p>This guide will help you write your first Crespi program in just a few minutes.</p>"},{"location":"en/quick-start/#hello-world","title":"Hello World","text":"<p>The simplest program in Crespi:</p> <pre><code>print(\"Hello, World!\")</code></pre> <p>Save this to a file <code>hello.crespi</code> and run it.</p> <p>Crespi offers two ways to execute your code:</p> <ul> <li>Interpreter - Run directly, supports all features</li> <li>Compiler - Compile to native executable</li> </ul> <p>Output: <pre><code>Hello, World!</code></pre></p>"},{"location":"en/quick-start/#variables-and-constants","title":"Variables and Constants","text":"<p>Use <code>var</code> for values that can change and <code>let</code> for fixed values:</p> <pre><code>var name = \"Maria\"\nlet PI = 3.14159\n\nprint(name)     // Maria\nprint(PI)       // 3.14159\n\nname = \"Carlos\"   // OK - var can change\n// PI = 3.0       // Error! - let cannot change</code></pre>"},{"location":"en/quick-start/#basic-data-types","title":"Basic Data Types","text":"<pre><code>// Numbers\nvar integer = 42\nvar decimal = 3.14\n\n// Text\nvar message = \"Hello\"\n\n// Booleans\nvar active = true\nvar inactive = false\n\n// Null\nvar empty = null</code></pre>"},{"location":"en/quick-start/#operators","title":"Operators","text":"<p>Crespi uses standard symbolic operators:</p> <pre><code>// Arithmetic\nvar sum = 5 + 3\nvar difference = 10 - 4\nvar product = 6 * 7\nvar quotient = 20 / 4\n\n// Comparison\nvar greater = 10 &gt; 5\nvar equal = 5 == 5\n\n// Logical\nvar both = true &amp;&amp; false   // false\nvar either = true || false  // true</code></pre>"},{"location":"en/quick-start/#conditionals","title":"Conditionals","text":"<pre><code>var age = 18\n\nif age &gt;= 18 {\n    print(\"Adult\")\n} else {\n    print(\"Minor\")\n}</code></pre> <p>With multiple conditions:</p> <pre><code>var grade = 85\n\nif grade &gt;= 90 {\n    print(\"Excellent\")\n} else if grade &gt;= 70 {\n    print(\"Pass\")\n} else {\n    print(\"Fail\")\n}</code></pre>"},{"location":"en/quick-start/#loops","title":"Loops","text":""},{"location":"en/quick-start/#while","title":"While","text":"<pre><code>var counter = 0\n\nwhile counter &lt; 5 {\n    print(counter)\n    counter += 1\n}\n// Output: 0, 1, 2, 3, 4</code></pre>"},{"location":"en/quick-start/#for-each","title":"For-each","text":"<pre><code>var numbers = [1, 2, 3, 4, 5]\n\nfor n in numbers {\n    print(n * 2)\n}\n// Output: 2, 4, 6, 8, 10</code></pre>"},{"location":"en/quick-start/#functions","title":"Functions","text":""},{"location":"en/quick-start/#basic-syntax","title":"Basic Syntax","text":"<pre><code>fn greet(name) {\n    print(\"Hello, \" + name + \"!\")\n}\n\ngreet(\"Ana\")  // Hello, Ana!</code></pre>"},{"location":"en/quick-start/#with-return-value","title":"With Return Value","text":"<pre><code>fn square(x) {\n    return x * x\n}\n\nvar r = square(5)\nprint(r)  // 25</code></pre>"},{"location":"en/quick-start/#short-syntax-single-expression","title":"Short Syntax (single expression)","text":"<pre><code>fn double(x) = x * 2\nfn sum(a, b) = a + b\n\nprint(double(7))     // 14\nprint(sum(3, 4))     // 7</code></pre>"},{"location":"en/quick-start/#default-parameters","title":"Default Parameters","text":"<pre><code>fn greet(name = \"World\") {\n    print(\"Hello, \" + name)\n}\n\ngreet()         // Hello, World\ngreet(\"Ana\")    // Hello, Ana</code></pre>"},{"location":"en/quick-start/#lists-and-dictionaries","title":"Lists and Dictionaries","text":""},{"location":"en/quick-start/#lists","title":"Lists","text":"<pre><code>var fruits = [\"apple\", \"orange\", \"pear\"]\n\nprint(fruits[0])           // apple\nprint(fruits.length())     // 3\n\nfruits.push(\"grape\")\nprint(fruits)              // [apple, orange, pear, grape]</code></pre>"},{"location":"en/quick-start/#dictionaries","title":"Dictionaries","text":"<pre><code>var person = {\n    \"name\": \"Luis\",\n    \"age\": 30\n}\n\nprint(person[\"name\"])   // Luis\nperson[\"city\"] = \"Madrid\"\nprint(person.keys())     // [name, age, city]</code></pre>"},{"location":"en/quick-start/#classes","title":"Classes","text":"<pre><code>class Rectangle(let width, let height) {\n    fn area() {\n        return this.width * this.height\n    }\n}\n\nvar rect = Rectangle(5, 3)\nprint(rect.area())  // 15</code></pre>"},{"location":"en/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Keywords Reference</li> <li>Built-in Functions</li> <li>Examples</li> </ul>"},{"location":"en/architecture/crates/","title":"Crate Structure","text":"<p>Language: Espa\u00f1ol | English</p> <p>The Crespi language is organized as a Cargo workspace with specialized crates for different concerns.</p>"},{"location":"en/architecture/crates/#crate-dependency-graph","title":"Crate Dependency Graph","text":"<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502 crespi-cli  \u2502  (Binary: crespi)\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u25bc            \u25bc            \u25bc\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 crespi-llvm \u2502 \u2502crespi-  \u2502\n      \u2502 (crespic)   \u2502 \u2502  core   \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n             \u2502             \u2502\n             \u25bc             \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n      \u2502crespi-codegen\u2502     \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n             \u2502             \u2502\n             \u25bc             \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n      \u2502crespi-runtime\u2502\u25c4\u2500\u2500\u2500\u2500\u2534\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502  crespi-ffi \u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n             \u2502\n             \u25bc\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502crespi-builtins\u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n      \u2502 crespi-i18n \u2502  \u2502crespi-schema\u2502  \u2502crespi-langpack\u2502\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n            (Internationalization support crates)</code></pre>"},{"location":"en/architecture/crates/#core-crates","title":"Core Crates","text":""},{"location":"en/architecture/crates/#crespi-core","title":"crespi-core","text":"<p>The heart of the language implementation.</p> Module Purpose <code>lexer/scanner.rs</code> Tokenization with Automatic Semicolon Insertion (ASI) <code>lexer/token.rs</code> Token types, keyword mapping (English primary, Spanish aliases) <code>parser/parser.rs</code> Recursive descent parser with climbing precedence <code>parser/ast.rs</code> AST types (Stmt, Expr) with Span for error locations <code>interpreter/eval.rs</code> Tree-walking interpreter <code>interpreter/environment.rs</code> Lexical scoping with <code>Rc&lt;RefCell&lt;Environment&gt;&gt;</code> <code>interpreter/builtins.rs</code> 60 built-in functions <code>interpreter/value.rs</code> Interpreter runtime values (Rc-based) <code>module/</code> Module system for multi-file compilation <p>Key features: - Full language parsing and interpretation - Extension method support - Generics (duck-typed) - Multi-file module resolution</p>"},{"location":"en/architecture/crates/#crespi-codegen","title":"crespi-codegen","text":"<p>HIR lowering and optimization shared by backends.</p> Module Purpose <code>hir.rs</code> High-level IR types between AST and backend codegen <code>lowering.rs</code> AST \u2192 HIR conversion, variable resolution, closure analysis <code>optimizer.rs</code> HIR optimization passes (constant folding, DCE, inlining) <p>Compilation pipeline: <pre><code>AST \u2192 HIR (lowering) \u2192 [Optimizer]</code></pre></p> <p>Key responsibilities: - Free variable analysis for closures - Spanish \u2192 English builtin name translation - GC context threading metadata - Entry-point signature validation</p>"},{"location":"en/architecture/crates/#crespi-llvm","title":"crespi-llvm","text":"<p>Native code generation via LLVM (Inkwell).</p> Module Purpose <code>compiler.rs</code> HIR \u2192 LLVM IR translation, object code emission <code>types.rs</code> Crespi \u2192 LLVM type mapping + signatures <code>passes.rs</code> LLVM optimization pipeline <p>Compilation pipeline: <pre><code>AST \u2192 HIR (lowering) \u2192 LLVM IR \u2192 Native Code</code></pre></p>"},{"location":"en/architecture/crates/#crespi-runtime","title":"crespi-runtime","text":"<p>Runtime support library for compiled programs.</p> Module Purpose <code>value.rs</code> Tagged value representation (tag + payload) used by the LLVM ABI <code>gc.rs</code> Reference counting with cycle detection <code>builtins.rs</code> C-compatible built-in functions implementation <p>Calling convention: - All functions receive <code>gc_ctx: *mut GcContext</code> as hidden first parameter - Entry point creates GC context, passes to all calls, destroys on exit</p> <p>See <code>docs/llvm/abi.md</code> for the current ABI.</p>"},{"location":"en/architecture/crates/#crespi-ffi","title":"crespi-ffi","text":"<p>Foreign Function Interface layer.</p> <p>Facilitates interoperability between Crespi and other languages (primarily Rust, extensible to C).</p> Module Purpose <code>marshal.rs</code> Data marshaling between Crespi values and host types <code>lib.rs</code> Utilities for defining <code>NativeFn</code> and FFI contexts <p>Key features: - Safe marshaling of primitives (<code>i32</code>, <code>f64</code>, <code>bool</code>, <code>String</code>) - <code>FromCrespi</code> and <code>ToCrespi</code> traits - C-ABI compatible function signatures</p>"},{"location":"en/architecture/crates/#crespi-tokio","title":"crespi-tokio","text":"<p>Tokio helper crate for Crespi.</p> <p>Provides a small, blocking wrapper over Tokio intended for Crespi FFI usage (sleep helpers, simple race/join utilities, and a <code>Runtime</code> wrapper).</p>"},{"location":"en/architecture/crates/#crespi-builtins","title":"crespi-builtins","text":"<p>Standard Library Native Bindings.</p> <p>Contains the native wrapper functions for the standard library, bridging the FFI layer to the core runtime implementation.</p> Module Purpose <code>lib.rs</code> Registration of built-in functions (print, math, string ops)"},{"location":"en/architecture/crates/#crespi-cli","title":"crespi-cli","text":"<p>Command-line interface for both interpreter and compiler.</p> Binary Purpose <code>crespi</code> Interpreter with REPL <code>crespic</code> Native compiler <p>Debug modes: - <code>crespi hir &lt;file&gt;</code> - Show HIR representation - <code>crespi llvm &lt;file&gt;</code> - Show LLVM IR</p>"},{"location":"en/architecture/crates/#crespi-cargo","title":"crespi-cargo","text":"<p>Cargo integration library.</p> <p>Implements the logic for analyzing Rust projects, extracting API metadata via <code>rustdoc</code>, and generating FFI bindings. Used by both the compiler (<code>crespic</code>) for automatic linking and the standalone <code>crespigen</code> tool.</p>"},{"location":"en/architecture/crates/#crespigen","title":"crespigen","text":"<p>Standalone FFI binding generator.</p> <p>A CLI tool that generates Crespi bindings for Rust libraries. - Parses <code>rustdoc</code> JSON output - Generates Rust FFI wrapper code - Compiles everything into a static library - Embeds <code>crespi-ffi</code> and <code>crespi-runtime</code> sources to be self-contained</p>"},{"location":"en/architecture/crates/#external-repositories","title":"External Repositories","text":""},{"location":"en/architecture/crates/#crespi-wasm","title":"crespi-wasm","text":"<p>WebAssembly bindings for browser execution. Moved to crespi-wasm.</p>"},{"location":"en/architecture/crates/#crespi-ide-support","title":"crespi-ide-support","text":"<p>VS Code extension and Language Server. Moved to crespi-ide-support.</p>"},{"location":"en/architecture/crates/#support-crates","title":"Support Crates","text":""},{"location":"en/architecture/crates/#crespi-i18n","title":"crespi-i18n","text":"<p>Internationalization infrastructure.</p> <p>Provides complete localization support for the Crespi language:</p> Component Purpose <code>langpack.rs</code> Loads <code>.crespilang</code> packs for keyword/builtin/operator/type aliases <code>bundle.rs</code> FTL-based translation bundle using Mozilla Fluent <code>locale.rs</code> Locale detection and management (system locale, <code>CRESPI_LANG</code> env) <code>locales/en/*.ftl</code> English translations <code>locales/es/*.ftl</code> Spanish translations <p>Translation coverage: - \u2705 Parser errors and labels - \u2705 Runtime errors and labels - \u2705 Lexer errors - \u2705 Module system errors (not found, circular dependency, symbol not found) - \u2705 Main error wrappers (syntax, lexer, runtime) - \u2705 Parser context strings (variable name, function name, etc.) - \u2705 CLI messages - \u2705 Builtin function errors</p> <p>Usage: <pre><code>use crespi_i18n::{t, tr};\n\n// Simple translation\nlet msg = t(\"label-here\");\n\n// Translation with arguments\nlet msg = tr!(\"runtime-undefined-variable\", name = var_name);</code></pre></p>"},{"location":"en/architecture/crates/#crespi-langpack","title":"crespi-langpack","text":"<p>Language pack tooling.</p> <p>CLI for validating, generating, and diffing language packs against <code>crespi-schema</code>. Pack files live in <code>crespi-i18n/packs/</code>.</p>"},{"location":"en/architecture/crates/#crespi-schema","title":"crespi-schema","text":"<p>Language pack schema.</p> <p>Defines the canonical enums for keywords, builtins, runtime types, and operator aliases used by packs and validation.</p>"},{"location":"en/architecture/crates/#building","title":"Building","text":"<pre><code># Build all crates\ncargo build\n\n# Build release (optimized)\ncargo build --release\n\n# Test all crates\ncargo test\n\n# Test specific crate\ncargo test -p crespi-core</code></pre>"},{"location":"en/architecture/crates/#see-also","title":"See Also","text":"<ul> <li>Architecture Overview</li> <li>Interoperability</li> </ul>"},{"location":"en/architecture/interoperability/","title":"Interoperability Layer (FFI)","text":"<p>The Crespi Foreign Function Interface (FFI) layer enables seamless communication between Crespi code and native host code. The architecture is designed with multi-language interoperability in mind, allowing for future expansion beyond the current Rust implementation.</p>"},{"location":"en/architecture/interoperability/#architecture","title":"Architecture","text":"<p>The FFI system is built on top of the <code>crespi-runtime</code> tagged value representation (<code>CrespiValue</code>) and the C Application Binary Interface (ABI).</p>"},{"location":"en/architecture/interoperability/#key-components","title":"Key Components","text":"<ol> <li>crespi-ffi: The core crate providing traits and utilities for marshaling data.</li> <li>NativeFn: The C-compatible function signature for native functions:     <pre><code>extern \"C\" fn(&amp;mut GcContext, *const CrespiValue, usize) -&gt; CrespiValue</code></pre></li> <li>Marshaling Traits:<ul> <li><code>FromCrespi</code>: Converts a <code>CrespiValue</code> to a Rust type.</li> <li><code>ToCrespi</code>: Converts a Rust type to a <code>CrespiValue</code> (may allocate on the heap).</li> </ul> </li> </ol>"},{"location":"en/architecture/interoperability/#current-implementation-rust-ffi","title":"Current Implementation: Rust FFI","text":"<p>The current FFI implementation provides seamless integration with Rust libraries. This serves as the foundation for future multi-language support.</p>"},{"location":"en/architecture/interoperability/#usage","title":"Usage","text":"<p>To expose a Rust function to Crespi:</p>"},{"location":"en/architecture/interoperability/#1-define-the-native-function","title":"1. Define the Native Function","text":"<p>Wrap your logic in an <code>extern \"C\"</code> function that handles argument marshaling.</p> <pre><code>use crespi_ffi::{GcContext, CrespiValue, FromCrespi, ToCrespi};\n\nextern \"C\" fn my_add(gc: &amp;mut GcContext, args: *const CrespiValue, count: usize) -&gt; CrespiValue {\n    // 1. Convert raw pointer to slice\n    let args = unsafe { std::slice::from_raw_parts(args, count) };\n\n    // 2. Validate argument count\n    if args.len() != 2 {\n        return CrespiValue::NULL; // Or handle error\n    }\n\n    // 3. Marshal arguments\n    let a = i32::from_crespi(&amp;args[0]).unwrap_or(0);\n    let b = i32::from_crespi(&amp;args[1]).unwrap_or(0);\n\n    // 4. Perform logic and return\n    (a + b).to_crespi(gc)\n}</code></pre>"},{"location":"en/architecture/interoperability/#2-register-the-function","title":"2. Register the Function","text":"<p>Register the function in the runtime's <code>GcContext</code> to make it available to Crespi code.</p> <pre><code>let native_fn = gc.alloc_nativa(\"add\".to_string(), my_add, 2);\ngc.set_global(\"add\".to_string(), native_fn);</code></pre>"},{"location":"en/architecture/interoperability/#3-call-from-crespi","title":"3. Call from Crespi","text":"<pre><code>print(add(10, 20)); // Output: 30</code></pre>"},{"location":"en/architecture/interoperability/#standard-library-built-ins","title":"Standard Library (Built-ins)","text":"<p>The standard library functions (like <code>print</code>, <code>math</code> functions, string operations) are implemented using this FFI layer in the <code>crespi-builtins</code> crate. This ensures that the core runtime remains minimal and focused on memory management and execution, while the standard library can grow independently.</p>"},{"location":"en/architecture/interoperability/#extern-functions-direct-ffi","title":"Extern Functions (Direct FFI)","text":"<p>For compiled Crespi code, you can call external Rust/C functions directly using <code>extern fn</code> declarations. This provides zero-overhead FFI without the marshaling layer.</p>"},{"location":"en/architecture/interoperability/#declaration-syntax","title":"Declaration Syntax","text":"<pre><code>extern fn my_compute(x: Int, y: Int) -&gt; Int\nextern fn my_sin(angle: Float) -&gt; Float</code></pre>"},{"location":"en/architecture/interoperability/#implementation-in-rust","title":"Implementation in Rust","text":"<pre><code>#[no_mangle]\npub extern \"C\" fn my_compute(x: i64, y: i64) -&gt; i64 {\n    x * y + 42\n}</code></pre>"},{"location":"en/architecture/interoperability/#compilation","title":"Compilation","text":"<pre><code># Build the Rust library as a static library\nrustc --crate-type=staticlib -o libmylib.a lib.rs\n\n# Compile Crespi code with the library\ncrespic main.crespi -L libmylib.a -o main</code></pre>"},{"location":"en/architecture/interoperability/#type-mapping","title":"Type Mapping","text":"Crespi LLVM IR Rust FFI <code>Int</code> <code>i64</code> <code>i64</code> <code>Double</code> <code>double</code> <code>f64</code> <code>Float</code> <code>float</code> <code>f32</code> <code>Bool</code> <code>i8</code> <code>bool</code> <code>Unit</code> <code>i8</code> <code>()</code> <p>For non-primitive types (<code>String</code>, <code>List</code>, <code>Dict</code>, classes), the compiler targets the wrapper ABI used by <code>crespi-cargo</code>:</p> <pre><code>extern \"C\" fn(*mut GcContext, *const CrespiValue, usize) -&gt; CrespiValue</code></pre> <p>The marshaling layer understands typed list objects for <code>List[Int]</code>, <code>List[Float]</code>/<code>List[Double]</code>, and <code>List[Bool]</code>, converting them to <code>Vec&lt;i64&gt;</code>, <code>Vec&lt;f32&gt;</code>/<code>Vec&lt;f64&gt;</code>, and <code>Vec&lt;bool&gt;</code> (and back) when crossing the FFI boundary.</p>"},{"location":"en/architecture/interoperability/#implementation-details","title":"Implementation Details","text":"<p>Extern functions are: - Declared as LLVM externs with <code>Linkage::External</code> - Called directly without CrespiValue boxing/unboxing - Linked at compile time via the system linker</p>"},{"location":"en/architecture/interoperability/#multi-language-interoperability-vision","title":"Multi-Language Interoperability Vision","text":"<p>The FFI architecture is designed to be extensible. While Rust is the current primary supported language, the C ABI foundation enables future support for additional languages. The marshaling layer abstracts language-specific details, allowing the same patterns to be applied to other native code sources.</p>"},{"location":"en/architecture/interoperability/#future-work","title":"Future Work","text":"<ul> <li>Plugin System: Support loading dynamic libraries (<code>.so</code>/<code>.dll</code>) at runtime.</li> <li>Procedural Macros: Automate the boilerplate for <code>extern \"C\"</code> wrappers.</li> <li>Safe Handles: Improved safety wrappers for heap objects passed to Rust.</li> <li>String/Object FFI: Support passing heap-allocated types (strings, lists) across the FFI boundary.</li> <li>Additional Language Support: Expand the FFI layer to support additional native languages through the C ABI.</li> </ul>"},{"location":"en/architecture/overview/","title":"Architecture Overview","text":"<p>Language: Espanol | English</p> <p>Crespi is a multilingual programming language (via language packs) implemented in Rust. It features a tree-walking interpreter for development and an LLVM-based native compiler for production.</p>"},{"location":"en/architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>+---------------------------------------------------------------------------+\n|                           Source Code                                      |\n|                        (.crespi files)                                     |\n+---------------------------------------------------------------------------+\n                                  |\n                                  v\n+---------------------------------------------------------------------------+\n|                         Lexer/Scanner                                      |\n|              (Tokenization with ASI, keyword mapping)                      |\n|                   English -&gt; Token &lt;- Spanish                              |\n+---------------------------------------------------------------------------+\n                                  |\n                                  v\n+---------------------------------------------------------------------------+\n|                            Parser                                          |\n|           (Recursive descent with climbing precedence)                     |\n|                         Produces AST                                       |\n+---------------------------------------------------------------------------+\n                                  |\n                    +-------------+-------------+\n                    v                           v\n+---------------------------+     +-----------------------------------+\n|       Interpreter         |     |         Native Compiler            |\n|   (Tree-walking eval)     |     |                                    |\n|                           |     |    +-------------------------+    |\n|  +---------------------+  |     |    |   HIR (High-level IR)   |    |\n|  |    Environment      |  |     |    |  (Lowering from AST)    |    |\n|  |  (Lexical scoping)  |  |     |    +-------------------------+    |\n|  +---------------------+  |     |                |                   |\n|                           |     |                v                   |\n|  +---------------------+  |     |    +-------------------------+    |\n|  |   Value (Rc-based)  |  |     |    |       LLVM IR          |    |\n|  |   Interpreter types |  |     |    |   (Code generation)     |    |\n|  +---------------------+  |     |    +-------------------------+    |\n+---------------------------+     |                |                   |\n            |                     |                v                   |\n            v                     |    +-------------------------+    |\n+---------------------------+     |    |    Native Executable    |    |\n|        Output             |     |    |    (+ crespi-runtime)   |    |\n+---------------------------+     |    +-------------------------+    |\n                                  +-----------------------------------+</code></pre>"},{"location":"en/architecture/overview/#key-design-decisions","title":"Key Design Decisions","text":""},{"location":"en/architecture/overview/#1-english-first-multilingual-support","title":"1. English-First Multilingual Support","text":"<p>The language core uses English as the canonical form: - English keywords (<code>var</code>, <code>class</code>, <code>fn</code>, <code>this</code>) are primary - Spanish keywords (<code>variable</code>, <code>tipo</code>, <code>bloque</code>, <code>yo</code>) are aliases defined in the lexer - All internal code, compiler passes, and runtime use English identifiers - Spanish translation happens at the lexer level (token -&gt; same TokenKind)</p> <p>This ensures: - Consistent internal representation - Easy addition of more languages in the future - No runtime overhead for language switching</p>"},{"location":"en/architecture/overview/#language-pack-workflow","title":"Language Pack Workflow","text":"<ul> <li><code>crespi-schema</code> defines the source-of-truth lists for keywords, builtins, runtime type aliases, and operator aliases.</li> <li><code>crespi-langpack</code> validates <code>.crespilang</code> files against the schema (validate/diff).</li> <li><code>crespi-i18n</code> loads packs and provides forward/reverse maps.</li> <li>The lexer uses the reverse maps to normalize localized keywords/operators/builtins into English tokens and identifiers.</li> </ul>"},{"location":"en/architecture/overview/#2-value-model-tagged-values","title":"2. Value Model (Tagged Values)","text":"<p>The LLVM backend uses a tagged value struct (tag + payload) for dynamic values and native machine types for statically known primitives. See <code>docs/llvm/abi.md</code> for the current ABI.</p>"},{"location":"en/architecture/overview/#3-reference-counting-with-cycle-detection","title":"3. Reference Counting with Cycle Detection","text":"<p>The runtime uses reference counting with cycle detection: - Each heap object has a reference count - Cycles detected via mark-sweep when counts don't reach zero - Closure environments properly tracked for captures</p>"},{"location":"en/architecture/overview/#4-two-execution-modes","title":"4. Two Execution Modes","text":"Mode Binary Use Case Interpreter <code>crespi</code> Development, REPL, debugging Compiler <code>crespic</code> Production, performance-critical <p>Both modes support the full language feature set.</p>"},{"location":"en/architecture/overview/#5-duck-typed-generics","title":"5. Duck-Typed Generics","text":"<p>Generics use square bracket syntax to avoid ambiguity: <pre><code>class Box[T](let value)    // Not &lt;T&gt; to avoid comparison operator ambiguity</code></pre></p> <p>Type parameters are parsed but not enforced at runtime (duck typing).</p>"},{"location":"en/architecture/overview/#6-interpretercompiler-parity","title":"6. Interpreter/Compiler Parity","text":"<ul> <li>Both modes rely on English canonical names after lexing.</li> <li>Builtins must be implemented in <code>crespi-core</code> (interpreter) and <code>crespi-runtime</code> (compiled), plus registered in codegen (<code>lowering.rs</code>, <code>compiler.rs</code>).</li> <li>When adding keywords/operators/builtins, update <code>crespi-schema</code>, language packs, and the reference docs together.</li> <li>Constants like <code>PI</code>/<code>E</code> are aliases for <code>pi()</code>/<code>e()</code> during compilation.</li> </ul>"},{"location":"en/architecture/overview/#data-flow","title":"Data Flow","text":""},{"location":"en/architecture/overview/#interpretation-flow","title":"Interpretation Flow","text":"<pre><code>Source -&gt; Lexer -&gt; Parser -&gt; AST -&gt; Interpreter -&gt; Value\n                                     |\n                              Environment (scopes)</code></pre>"},{"location":"en/architecture/overview/#compilation-flow","title":"Compilation Flow","text":"<pre><code>Source -&gt; Lexer -&gt; Parser -&gt; AST -&gt; HIR (lowering) -&gt; LLVM IR -&gt; Object Code\n                                      |                              |\n                            Variable resolution              Link with runtime\n                            Free variable analysis                   |\n                            Builtin translation              Native Executable</code></pre>"},{"location":"en/architecture/overview/#module-system","title":"Module System","text":"<p>Inspired by Swift, the module system supports:</p> <pre><code>import Helpers                  // Entire module\nimport Math.Vector              // Nested module\nimport Helper { double, Point } // Explicit symbols\nimport class Math.Point         // Specific class\nimport fn Utils.format          // Specific function</code></pre> <p>Resolution order: 1. Relative to importing file 2. Source root 3. Additional <code>-I</code> search paths</p> <p>File naming: - <code>snake_case.crespi</code> -&gt; <code>PascalCase</code> module name - Directories create nested modules</p>"},{"location":"en/architecture/overview/#see-also","title":"See Also","text":"<ul> <li>Crate Structure - Description of each crate</li> </ul>"},{"location":"en/contributing/CONTRIBUTING/","title":"Contributing to Crespi","text":"<p>Language: Espa\u00f1ol | English</p> <p>Thank you for your interest in contributing to Crespi! This guide will help you get started.</p>"},{"location":"en/contributing/CONTRIBUTING/#development-environment","title":"Development Environment","text":""},{"location":"en/contributing/CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.70+ with Cargo</li> <li>Git</li> </ul>"},{"location":"en/contributing/CONTRIBUTING/#clone-and-build","title":"Clone and Build","text":"<pre><code>git clone https://github.com/crespi-lang/crespi-lang.git\ncd crespi-lang\n\n# Build the language\ncd lang\ncargo build\n\n# Run tests\ncargo test</code></pre>"},{"location":"en/contributing/CONTRIBUTING/#project-structure","title":"Project Structure","text":"<pre><code>crespi-lang/\n\u251c\u2500\u2500 crates/\n\u2502   \u251c\u2500\u2500 crespi-core/     # Parser, interpreter, AST\n\u2502   \u251c\u2500\u2500 crespi-codegen/  # HIR lowering + optimization\n\u2502   \u251c\u2500\u2500 crespi-llvm/     # Native compiler (LLVM)\n\u2502   \u251c\u2500\u2500 crespi-runtime/  # Runtime library\n\u2502   \u251c\u2500\u2500 crespi-cli/      # Command-line interface\n\u2502   \u251c\u2500\u2500 crespi-i18n/     # Internationalization\n\u2502   \u251c\u2500\u2500 crespi-langpack/ # Language packs\n\u2502   \u251c\u2500\u2500 crespi-schema/   # Schema definitions\n\u2502   \u251c\u2500\u2500 crespi-cargo/    # Cargo integration logic\n\u2502   \u2514\u2500\u2500 crespigen/       # FFI binding generator\n\u251c\u2500\u2500 examples/             # Example programs (scripts + Cargo projects)\n\u251c\u2500\u2500 docs/                # Documentation\n\u2514\u2500\u2500 Cargo.toml           # Workspace configuration</code></pre>"},{"location":"en/contributing/CONTRIBUTING/#common-commands","title":"Common Commands","text":""},{"location":"en/contributing/CONTRIBUTING/#rust-language-core","title":"Rust (Language Core)","text":"<pre><code># Build\ncargo build                    # Debug build\ncargo build --release          # Release build\n\n# Test\ncargo test                     # Run all tests\ncargo test -p crespi-core      # Test specific crate\n\n# Lint and Format\ncargo fmt                      # Format code\ncargo clippy --workspace --all-targets -- -D warnings\n\n# Run\ncargo run --bin crespi         # Start REPL\ncargo run --bin crespi -- file.crespi    # Interpret file\ncargo run --bin crespic -- file.crespi   # Compile to native\n\n# Debug output\ncargo run --bin crespi -- hir file.crespi   # Show HIR\ncargo run --bin crespi -- llvm file.crespi  # Show LLVM IR</code></pre>"},{"location":"en/contributing/CONTRIBUTING/#testing","title":"Testing","text":""},{"location":"en/contributing/CONTRIBUTING/#running-tests","title":"Running Tests","text":"<pre><code># All tests\ncargo test\n\n# Specific crate\ncargo test -p crespi-core\ncargo test -p crespi-codegen\ncargo test -p crespi-runtime\n\n# Specific test\ncargo test test_name\n\n# With output\ncargo test -- --nocapture</code></pre>"},{"location":"en/contributing/CONTRIBUTING/#test-organization","title":"Test Organization","text":"<ul> <li>Unit tests: In <code>src/</code> files with <code>#[cfg(test)]</code> modules</li> <li>Integration tests: In <code>crates/crespi-core/tests/</code></li> <li>Sample programs: <code>examples/simple_scripts/*.crespi</code> serve as documentation and test cases; Cargo-based demos live in <code>examples/cargo_projects/</code></li> <li>Locale-sensitive tests: If tests use localized syntax (e.g., Spanish keywords), set locale in helpers via <code>crespi_i18n::set_locale(Locale::Spanish)</code></li> <li>Schema parity tests: Builtin lists are validated against <code>crespi-schema</code> in interpreter/runtime/codegen tests</li> </ul>"},{"location":"en/contributing/CONTRIBUTING/#adding-tests","title":"Adding Tests","text":"<ol> <li>For new language features, add a sample in <code>examples/simple_scripts/</code></li> <li>Add integration tests in the appropriate <code>tests/</code> directory</li> <li>Ensure both interpreter and compiler handle the feature</li> </ol>"},{"location":"en/contributing/CONTRIBUTING/#pull-request-process","title":"Pull Request Process","text":""},{"location":"en/contributing/CONTRIBUTING/#before-submitting","title":"Before Submitting","text":"<ol> <li> <p>Run all checks locally: <pre><code>cargo fmt\ncargo clippy --workspace --all-targets -- -D warnings\ncargo test</code></pre></p> </li> <li> <p>Ensure documentation is updated if you changed behavior</p> </li> <li> <p>Add tests for new features or bug fixes</p> </li> </ol>"},{"location":"en/contributing/CONTRIBUTING/#pr-guidelines","title":"PR Guidelines","text":"<ul> <li>One feature/fix per PR - Keep changes focused</li> <li>Descriptive title - Summarize the change</li> <li>Link related issues - Reference with <code>Fixes #123</code> or <code>Closes #123</code></li> <li>Update AGENTS.md if you change language syntax or commands</li> </ul>"},{"location":"en/contributing/CONTRIBUTING/#commit-messages","title":"Commit Messages","text":"<p>Use clear, descriptive commit messages:</p> <pre><code>Add support for guard statements\n\n- Implement `guard` keyword for early returns\n- Add tests for guard with pattern matching\n- Update documentation</code></pre>"},{"location":"en/contributing/CONTRIBUTING/#code-review","title":"Code Review","text":"<p>All PRs require review before merging. Reviewers will check:</p> <ul> <li>[ ] Code follows project style (see Code Style)</li> <li>[ ] Tests pass and new tests added where appropriate</li> <li>[ ] Documentation updated</li> <li>[ ] No breaking changes without discussion</li> <li>[ ] Commit history is clean</li> </ul>"},{"location":"en/contributing/CONTRIBUTING/#areas-to-contribute","title":"Areas to Contribute","text":""},{"location":"en/contributing/CONTRIBUTING/#good-first-issues","title":"Good First Issues","text":"<p>Look for issues labeled <code>good first issue</code> on GitHub.</p>"},{"location":"en/contributing/CONTRIBUTING/#feature-ideas","title":"Feature Ideas","text":"<ul> <li>Additional built-in functions</li> <li>Performance optimizations</li> <li>Better error messages</li> <li>IDE integrations</li> <li>Documentation improvements</li> </ul>"},{"location":"en/contributing/CONTRIBUTING/#documentation","title":"Documentation","text":"<ul> <li>Fix typos or unclear explanations</li> <li>Add examples</li> <li>Translate to other languages</li> </ul>"},{"location":"en/contributing/CONTRIBUTING/#language-design-principles","title":"Language Design Principles","text":"<p>When proposing language changes, keep in mind:</p> <ol> <li>English-first: Core syntax uses English; Spanish via language pack</li> <li>Readable: Prefer clarity over brevity</li> <li>Consistent: Follow existing patterns</li> <li>Practical: Features should solve real problems</li> <li>Compatible: Avoid breaking existing code</li> </ol>"},{"location":"en/contributing/CONTRIBUTING/#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues: For bugs and feature requests</li> <li>Discussions: For questions and ideas</li> </ul>"},{"location":"en/contributing/CONTRIBUTING/#see-also","title":"See Also","text":"<ul> <li>Code Style Guide</li> <li>Architecture Overview</li> </ul>"},{"location":"en/contributing/code-style/","title":"Code Style Guide","text":"<p>Language: Espa\u00f1ol | English</p> <p>This guide covers coding conventions for the Crespi project.</p>"},{"location":"en/contributing/code-style/#rust-code","title":"Rust Code","text":""},{"location":"en/contributing/code-style/#formatting","title":"Formatting","text":"<p>Use <code>cargo fmt</code> for automatic formatting. The project uses default rustfmt settings.</p> <pre><code>cd lang\ncargo fmt</code></pre>"},{"location":"en/contributing/code-style/#linting","title":"Linting","text":"<p>All code must pass Clippy with warnings as errors:</p> <pre><code>cargo clippy --workspace --all-targets -- -D warnings</code></pre>"},{"location":"en/contributing/code-style/#naming-conventions","title":"Naming Conventions","text":"Item Convention Example Crates <code>kebab-case</code> <code>crespi-core</code> Modules <code>snake_case</code> <code>value_system</code> Types <code>PascalCase</code> <code>CrespiValue</code> Functions <code>snake_case</code> <code>parse_expression</code> Constants <code>SCREAMING_SNAKE_CASE</code> <code>MAX_STACK_SIZE</code> Variables <code>snake_case</code> <code>token_count</code>"},{"location":"en/contributing/code-style/#documentation","title":"Documentation","text":"<p>Document public items with <code>///</code> doc comments:</p> <pre><code>/// Parses an expression from the token stream.\n///\n/// # Arguments\n///\n/// * `tokens` - The token iterator\n///\n/// # Returns\n///\n/// The parsed expression AST node, or an error.\npub fn parse_expression(tokens: &amp;mut TokenStream) -&gt; Result&lt;Expr, ParseError&gt; {\n    // ...\n}</code></pre>"},{"location":"en/contributing/code-style/#error-handling","title":"Error Handling","text":"<ul> <li>Use <code>Result</code> for recoverable errors</li> <li>Use <code>?</code> operator for propagation</li> <li>Create specific error types for each module</li> <li>Include context in error messages</li> </ul> <pre><code>// Good: Specific error with context\nErr(ParseError::UnexpectedToken {\n    expected: \"identifier\",\n    found: token.kind,\n    span: token.span,\n})\n\n// Avoid: Generic string errors\nErr(\"unexpected token\".into())</code></pre>"},{"location":"en/contributing/code-style/#module-organization","title":"Module Organization","text":"<pre><code>// 1. Imports (grouped and sorted)\nuse std::collections::HashMap;\nuse std::rc::Rc;\n\nuse crate::parser::Expr;\nuse crate::value::Value;\n\n// 2. Constants\nconst MAX_RECURSION: usize = 1000;\n\n// 3. Types (structs, enums)\npub struct Interpreter { ... }\n\n// 4. Implementations\nimpl Interpreter { ... }\n\n// 5. Functions\npub fn evaluate(expr: &amp;Expr) -&gt; Value { ... }\n\n// 6. Tests (at bottom)\n#[cfg(test)]\nmod tests { ... }</code></pre>"},{"location":"en/contributing/code-style/#crespi-code-examples-and-tests","title":"Crespi Code (Examples and Tests)","text":""},{"location":"en/contributing/code-style/#keywords","title":"Keywords","text":"<p>Use English keywords in documentation and examples:</p> <pre><code>// Good\nvar name = \"Alice\"\nclass Person(let name, let age)\nfn greet() { ... }</code></pre> <p>Avoid localized keyword packs in English docs. Spanish examples belong in Spanish documentation only.</p>"},{"location":"en/contributing/code-style/#function-naming","title":"Function Naming","text":"<p>Use camelCase for function and method names:</p> <pre><code>// Good\nfn getValue() { ... }\nfn isEmpty() { ... }\nfn calculateTotal(items) { ... }\n\n// Avoid\nfn get_value() { ... }\nfn is_empty() { ... }\nfn calculate_total(items) { ... }</code></pre>"},{"location":"en/contributing/code-style/#class-naming","title":"Class Naming","text":"<p>Use PascalCase for class names:</p> <pre><code>// Good\nclass Person(let name, let age)\nclass HttpClient(let baseUrl)\nclass LinkedList[T]()\n\n// Avoid\nclass person(let name, let age)\nclass http_client(let baseUrl)</code></pre>"},{"location":"en/contributing/code-style/#formatting_1","title":"Formatting","text":"<ul> <li>Indentation: 4 spaces</li> <li>Braces: Same line as declaration</li> <li>Line length: Reasonable (no strict limit)</li> </ul> <pre><code>class Rectangle(let width, let height) {\n    fn area() {\n        return this.width * this.height\n    }\n\n    fn perimeter() {\n        return 2 * (this.width + this.height)\n    }\n}</code></pre>"},{"location":"en/contributing/code-style/#typescriptjavascript-web-extension","title":"TypeScript/JavaScript (Web &amp; Extension)","text":""},{"location":"en/contributing/code-style/#formatting_2","title":"Formatting","text":"<p>Use Prettier with project configuration:</p> <pre><code>npm run format</code></pre>"},{"location":"en/contributing/code-style/#linting_1","title":"Linting","text":"<p>ESLint with project configuration:</p> <pre><code>npm run lint</code></pre>"},{"location":"en/contributing/code-style/#naming","title":"Naming","text":"Item Convention Example Variables <code>camelCase</code> <code>tokenCount</code> Functions <code>camelCase</code> <code>parseExpression</code> Classes <code>PascalCase</code> <code>TokenParser</code> Constants <code>SCREAMING_SNAKE_CASE</code> <code>MAX_TOKENS</code> Files <code>kebab-case</code> <code>token-parser.ts</code>"},{"location":"en/contributing/code-style/#svelte-components","title":"Svelte Components","text":"<ul> <li>Use Svelte 5 runes (<code>$state</code>, <code>$derived</code>, <code>$effect</code>)</li> <li>Component files use PascalCase: <code>CodeEditor.svelte</code></li> </ul>"},{"location":"en/contributing/code-style/#git-conventions","title":"Git Conventions","text":""},{"location":"en/contributing/code-style/#branch-names","title":"Branch Names","text":"<pre><code>feature/add-guard-statement\nfix/parser-crash-on-empty-input\ndocs/update-architecture\nrefactor/simplify-evaluator</code></pre>"},{"location":"en/contributing/code-style/#commit-messages","title":"Commit Messages","text":"<p>Format: <pre><code>&lt;type&gt;: &lt;short description&gt;\n\n&lt;optional body with details&gt;</code></pre></p> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation - <code>refactor</code>: Code restructuring - <code>test</code>: Adding tests - <code>chore</code>: Maintenance tasks</p> <p>Examples: <pre><code>feat: Add guard statement support\n\n- Implement guard keyword for early returns\n- Support pattern matching in guard conditions\n- Add 5 test cases\n\nfix: Prevent stack overflow in recursive calls\n\nThe interpreter now detects deep recursion and\nreturns a clear error instead of crashing.\n\ndocs: Update architecture diagrams</code></pre></p>"},{"location":"en/contributing/code-style/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>The project uses pre-commit hooks that run automatically:</p> <ol> <li>Rust formatting (<code>cargo fmt</code>)</li> <li>Rust linting (<code>cargo clippy</code>)</li> <li>Web formatting (<code>prettier</code>)</li> <li>Web linting (<code>eslint</code>)</li> <li>Extension formatting (<code>prettier</code>)</li> <li>Extension linting (<code>eslint</code>)</li> </ol> <p>If a hook fails, fix the issues before committing.</p>"},{"location":"en/contributing/code-style/#see-also","title":"See Also","text":"<ul> <li>Contributing Guide</li> <li>Architecture Overview</li> </ul>"},{"location":"en/guide/advanced/","title":"Advanced Features","text":"<p>Language: Espa\u00f1ol | English</p> <p>This chapter covers Crespi's advanced features: memoization, tail-call optimization, and more.</p>"},{"location":"en/guide/advanced/#memoization","title":"Memoization","text":"<p>Memoization caches function results to avoid repeated calculations.</p>"},{"location":"en/guide/advanced/#the-memoize-decorator","title":"The <code>@memoize</code> Decorator","text":"<p>Apply automatic memoization to a function:</p> <pre><code>@memoize\nfn fibonacci(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return n\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nprint(fibonacci(40))  // Fast thanks to cache</code></pre>"},{"location":"en/guide/advanced/#without-memoization-slow","title":"Without Memoization (Slow)","text":"<p>Without memoization, Fibonacci calculates the same values many times:</p> <pre><code>// Without @memoize - very slow for large n\nfn fib_slow(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return n\n    }\n    return fib_slow(n - 1) + fib_slow(n - 2)\n}\n\n// fib_slow(40) would take a very long time</code></pre>"},{"location":"en/guide/advanced/#the-memoize-function","title":"The <code>memoize()</code> Function","text":"<p>You can also use the <code>memoize()</code> function directly:</p> <pre><code>fn factorial(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return 1\n    }\n    return n * factorial(n - 1)\n}\n\nvar factorial_memo = memoize(factorial)\n\nprint(factorial_memo(100))  // Uses cache\nprint(factorial_memo(100))  // Retrieves from cache instantly</code></pre>"},{"location":"en/guide/advanced/#when-to-use-memoization","title":"When to Use Memoization","text":"<ul> <li>Recursive functions with repeated subproblems</li> <li>Pure functions (no side effects)</li> <li>Expensive calculations with the same arguments</li> </ul> <pre><code>// Good case: expensive calculation, repeated arguments\n@memoize\nfn calculate_route(origin: String, destination: String) -&gt; String {\n    // Simulate expensive calculation\n    return origin + \" -&gt; \" + destination\n}\n\n// Bad case: function with side effects\n// Do not use @memoize here\nfn get_time() -&gt; String {\n    // This would return the same cached value forever\n    return \"current time\"\n}</code></pre>"},{"location":"en/guide/advanced/#with-short-syntax","title":"With Short Syntax","text":"<pre><code>@memoize\nfn square(n: Int) -&gt; Int = n * n\n\n@memoize\nfn cube(n: Int) -&gt; Int = n * n * n\n\nprint(square(1000))  // Calculated\nprint(square(1000))  // From cache</code></pre>"},{"location":"en/guide/advanced/#function-inlining","title":"Function Inlining","text":"<p>Function inlining replaces function calls with the function body, eliminating call overhead.</p>"},{"location":"en/guide/advanced/#the-inline-decorator","title":"The <code>@inline</code> Decorator","text":"<p>Mark functions for inlining at compile time:</p> <pre><code>@inline\nfn double(x: Int) -&gt; Int {\n    return x * 2\n}\n\nfn main() {\n    // The compiler replaces this with: result = 21 * 2\n    var result = double(21)\n    print(result)\n}</code></pre>"},{"location":"en/guide/advanced/#when-to-use-inline","title":"When to Use <code>@inline</code>","text":"<ul> <li>Small utility functions called frequently</li> <li>Functions in performance-critical loops</li> <li>Simple getters/setters</li> </ul> <pre><code>@inline\nfn square(n: Int) -&gt; Int = n * n\n\n@inline\nfn isPositive(n: Int) -&gt; Bool = n &gt; 0\n\n// Good candidates: small, frequently called\nfor i in range(1000000) {\n    if isPositive(i) {\n        total = total + square(i)\n    }\n}</code></pre>"},{"location":"en/guide/advanced/#limitations","title":"Limitations","text":"<ul> <li>Recursive functions are never inlined (would cause infinite expansion)</li> <li>Functions with closures are not inlined</li> <li>The decorator has no effect on the interpreter (runtime behavior unchanged)</li> </ul>"},{"location":"en/guide/advanced/#auto-inlining-at-o2","title":"Auto-Inlining (at -O2)","text":"<p>At optimization level <code>-O2</code>, the compiler automatically inlines small functions (\u22645 statements) even without the decorator:</p> <pre><code>// This function is auto-inlined at -O2\nfn add(a: Int, b: Int) -&gt; Int {\n    return a + b\n}</code></pre> <p>See Compiler Documentation for more details.</p>"},{"location":"en/guide/advanced/#tail-call-optimization-tco","title":"Tail-Call Optimization (TCO)","text":"<p>Crespi automatically optimizes tail-recursive functions, allowing deep recursion without stack overflow.</p>"},{"location":"en/guide/advanced/#what-is-tail-recursion","title":"What is Tail Recursion?","text":"<p>A recursive call is \"tail\" when it's the last operation of the function:</p> <pre><code>// Tail recursion - optimizable\nfn factorial_tail(n: Int, acc: Int = 1) -&gt; Int {\n    if n &lt;= 1 {\n        return acc\n    }\n    return factorial_tail(n - 1, n * acc)  // Last operation\n}\n\n// NOT tail recursion\nfn factorial_normal(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return 1\n    }\n    return n * factorial_normal(n - 1)  // Multiplication after\n}</code></pre>"},{"location":"en/guide/advanced/#benefits-of-tco","title":"Benefits of TCO","text":"<pre><code>// Without TCO, this would cause stack overflow\n// With TCO, it works for very large values\n\nfn sum_to(n: Int, acc: Int = 0) -&gt; Int {\n    if n &lt;= 0 {\n        return acc\n    }\n    return sum_to(n - 1, acc + n)\n}\n\nprint(sum_to(10000))  // 50005000 - Works thanks to TCO</code></pre>"},{"location":"en/guide/advanced/#converting-to-tail-recursion","title":"Converting to Tail Recursion","text":"<p>General pattern: use an accumulator:</p> <pre><code>// Fibonacci with accumulators (TCO)\nfn fibonacci_tail(n: Int, a: Int = 0, b: Int = 1) -&gt; Int {\n    if n == 0 {\n        return a\n    }\n    if n == 1 {\n        return b\n    }\n    return fibonacci_tail(n - 1, b, a + b)\n}\n\nprint(fibonacci_tail(50))  // Fast and efficient</code></pre>"},{"location":"en/guide/advanced/#conversion-examples","title":"Conversion Examples","text":"<p>Power:</p> <pre><code>// Normal\nfn power(base: Int, exp: Int) -&gt; Int {\n    if exp == 0 {\n        return 1\n    }\n    return base * power(base, exp - 1)  // Not tail\n}\n\n// With TCO\nfn power_tail(base: Int, exp: Int, acc: Int = 1) -&gt; Int {\n    if exp == 0 {\n        return acc\n    }\n    return power_tail(base, exp - 1, acc * base)  // Is tail\n}\n\nprint(power_tail(2, 20))  // 1048576</code></pre>"},{"location":"en/guide/advanced/#single-expression-functions","title":"Single-Expression Functions","text":"<p>Compact syntax for simple functions:</p> <pre><code>// Standard form\nfn double(x: Int) -&gt; Int {\n    return x * 2\n}\n\n// Single expression (equivalent)\nfn double(x: Int) -&gt; Int = x * 2</code></pre>"},{"location":"en/guide/advanced/#multiple-parameters","title":"Multiple Parameters","text":"<pre><code>fn sum(a: Int, b: Int) -&gt; Int = a + b\nfn average(a: Float, b: Float) -&gt; Float = (a + b) / 2.0\n\n// For complex logic, use standard form\nfn maximum(a: Int, b: Int) -&gt; Int {\n    if a &gt; b {\n        return a\n    }\n    return b\n}</code></pre>"},{"location":"en/guide/advanced/#in-classes","title":"In Classes","text":"<pre><code>class Vector(let x: Float, let y: Float) {\n    fn magnitude() -&gt; Float = (this.x * this.x + this.y * this.y)\n    fn scale(factor: Float) -&gt; Vector = Vector(this.x * factor, this.y * factor)\n}</code></pre>"},{"location":"en/guide/advanced/#automatic-semicolon-insertion-asi","title":"Automatic Semicolon Insertion (ASI)","text":"<p>Crespi automatically inserts semicolons at the end of lines when appropriate.</p>"},{"location":"en/guide/advanced/#when-it-works","title":"When It Works","text":"<pre><code>// Semicolons are optional at end of line\nvar x = 10\nvar y = 20\nprint(x + y)\n\n// Equivalent to:\nvar x = 10;\nvar y = 20;\nprint(x + y);</code></pre>"},{"location":"en/guide/advanced/#when-to-use-explicit-semicolons","title":"When to Use Explicit Semicolons","text":"<p>For multiple statements on one line:</p> <pre><code>var a = 1; var b = 2; print(a + b)</code></pre>"},{"location":"en/guide/advanced/#advanced-closures","title":"Advanced Closures","text":""},{"location":"en/guide/advanced/#encapsulated-state","title":"Encapsulated State","text":"<pre><code>fn create_module() -&gt; Dict[String, () -&gt; Int | (Int) -&gt; ()] {\n    var _private = 0\n\n    fn increment() {\n        _private += 1\n    }\n\n    fn get() -&gt; Int {\n        return _private\n    }\n\n    fn set(value: Int) {\n        _private = value\n    }\n\n    return {\n        \"increment\": increment,\n        \"get\": get,\n        \"set\": set\n    }\n}\n\nvar module = create_module()\nmodule[\"increment\"]()\nmodule[\"increment\"]()\nprint(module[\"get\"]())  // 2</code></pre>"},{"location":"en/guide/advanced/#currying","title":"Currying","text":"<pre><code>fn curry_add(a: Int) -&gt; (Int) -&gt; Int {\n    fn add_b(b: Int) -&gt; Int {\n        return a + b\n    }\n    return add_b\n}\n\nvar add_5 = curry_add(5)\nprint(add_5(3))   // 8\nprint(add_5(10))  // 15</code></pre>"},{"location":"en/guide/advanced/#manual-memoization","title":"Manual Memoization","text":"<pre><code>fn [T, U] create_cache(fn: (T) -&gt; U) -&gt; (T) -&gt; U {\n    var cache = {}\n\n    fn cached(arg: T) -&gt; U {\n        var key = str(arg)\n\n        if cache.contains(key) {\n            return cache[key]\n        }\n\n        var result = fn(arg)\n        cache[key] = result\n        return result\n    }\n\n    return cached\n}\n\nfn expensive_calc(n: Int) -&gt; Int {\n    // Simulate expensive calculation\n    return n * n\n}\n\nvar cached_calc = create_cache(expensive_calc)\nprint(cached_calc(100))  // Calculates\nprint(cached_calc(100))  // From cache</code></pre>"},{"location":"en/guide/advanced/#higher-order-functions","title":"Higher-Order Functions","text":""},{"location":"en/guide/advanced/#function-composition","title":"Function Composition","text":"<pre><code>fn [T, U, V] compose(f: (U) -&gt; V, g: (T) -&gt; U) -&gt; (T) -&gt; V {\n    fn composed(x: T) -&gt; V {\n        return f(g(x))\n    }\n    return composed\n}\n\nfn double(x: Int) -&gt; Int = x * 2\nfn increment(x: Int) -&gt; Int = x + 1\n\nvar double_then_increment = compose(increment, double)\nprint(double_then_increment(5))  // 11 (5*2 + 1)\n\nvar increment_then_double = compose(double, increment)\nprint(increment_then_double(5))  // 12 ((5+1) * 2)</code></pre>"},{"location":"en/guide/advanced/#partial-application","title":"Partial Application","text":"<pre><code>fn [A, B, R] partial(fn: (A, B) -&gt; R, first_arg: A) -&gt; (B) -&gt; R {\n    fn applied(second_arg: B) -&gt; R {\n        return fn(first_arg, second_arg)\n    }\n    return applied\n}\n\nfn power(base: Int, exp: Int) -&gt; Int {\n    var r = 1\n    var i = 0\n    while i &lt; exp {\n        r = r * base\n        i += 1\n    }\n    return r\n}\n\nvar power_of_2 = partial(power, 2)  // base = 2\nprint(power_of_2(3))  // 2^3 = 8\nprint(power_of_2(4))  // 2^4 = 16</code></pre>"},{"location":"en/guide/advanced/#pipeline","title":"Pipeline","text":"<pre><code>fn [T] pipe(value: T, functions: List[(T) -&gt; T]) -&gt; T {\n    var result = value\n\n    for fn in functions {\n        result = fn(result)\n    }\n\n    return result\n}\n\nfn double(x: Int) -&gt; Int = x * 2\nfn increment(x: Int) -&gt; Int = x + 1\nfn square(x: Int) -&gt; Int = x * x\n\nvar result = pipe(3, [double, increment, square])\nprint(result)  // ((3*2)+1)^2 = 49</code></pre>"},{"location":"en/guide/advanced/#design-patterns","title":"Design Patterns","text":""},{"location":"en/guide/advanced/#custom-iterator","title":"Custom Iterator","text":"<pre><code>fn create_range(start: Int, end: Int) -&gt; Dict[String, () -&gt; Bool | () -&gt; Int] {\n    var current = start\n\n    fn has_next() -&gt; Bool {\n        return current &lt; end\n    }\n\n    fn next() -&gt; Int {\n        var value = current\n        current += 1\n        return value\n    }\n\n    return {\n        \"has_next\": has_next,\n        \"next\": next\n    }\n}\n\nvar range = create_range(1, 5)\n\nwhile range[\"has_next\"]() {\n    print(range[\"next\"]())\n}\n// 1, 2, 3, 4</code></pre>"},{"location":"en/guide/advanced/#observer-simplified","title":"Observer (Simplified)","text":"<pre><code>fn [T] create_observable() -&gt; Dict[String, Any] {\n    var _observers = []\n    var _value: T? = null\n\n    fn subscribe(observer: (T) -&gt; ()) {\n        _observers.push(observer)\n    }\n\n    fn notify() {\n        for obs in _observers {\n            obs(_value)\n        }\n    }\n\n    fn set(new_value: T) {\n        _value = new_value\n        notify()\n    }\n\n    fn get() -&gt; T? {\n        return _value\n    }\n\n    return {\n        \"subscribe\": subscribe,\n        \"set\": set,\n        \"get\": get\n    }\n}\n\nvar state = create_observable()\n\nstate[\"subscribe\"](fn(value: Int) {\n    print(\"Observer 1: \" + str(value))\n})\n\nstate[\"subscribe\"](fn(value: Int) {\n    print(\"Observer 2: \" + str(value))\n})\n\nstate[\"set\"](42)\n// Observer 1: 42\n// Observer 2: 42</code></pre>"},{"location":"en/guide/advanced/#see-also","title":"See Also","text":"<ul> <li>Functions</li> <li>Classes and Objects</li> <li>Built-in Functions Reference</li> </ul>"},{"location":"en/guide/classes/","title":"Classes and Objects","text":"<p>Language: Espa\u00f1ol | English</p> <p>Crespi supports object-oriented programming with classes, inheritance, and methods.</p>"},{"location":"en/guide/classes/#defining-a-class","title":"Defining a Class","text":"<p>Use <code>class</code> to define a class:</p> <pre><code>class Person(var name: String, var age: Int) {\n    fn introduce() {\n        print(\"I am \" + this.name + \", \" + str(this.age) + \" years old\")\n    }\n}</code></pre>"},{"location":"en/guide/classes/#creating-instances","title":"Creating Instances","text":"<p>Create objects by calling the class directly:</p> <pre><code>var ana = Person(\"Ana\", 25)\nvar luis = Person(\"Luis\", 30)\n\nana.introduce()   // I am Ana, 25 years old\nluis.introduce()  // I am Luis, 30 years old</code></pre>"},{"location":"en/guide/classes/#the-constructor-constructor","title":"The Constructor: <code>constructor</code>","text":"<p>The <code>constructor</code> method is called automatically when creating an instance:</p> <pre><code>class Rectangle {\n    constructor(width: Int, height: Int) {\n        this.width = width\n        this.height = height\n        print(\"Rectangle created: \" + str(width) + \"x\" + str(height))\n    }\n}\n\nvar rect = Rectangle(10, 5)\n// Output: Rectangle created: 10x5</code></pre> <p>Primary constructors can be declared in the class header (Kotlin-style). Use <code>var</code> or <code>let</code> to make parameters into instance properties:</p> <ul> <li><code>var</code>: Creates a mutable property that can be modified after construction</li> <li><code>let</code>: Creates an immutable property that cannot be changed after construction</li> <li>No modifier: The parameter is only used for construction, not stored as a property</li> </ul> <pre><code>class Point(let x: Int, let y: Int) {\n}\n\nvar p = Point(3, 4)\nprint(p.x)  // 3\nprint(p.y)  // 4\n// p.x = 10  // Error: cannot modify immutable property</code></pre> <p>Use <code>var</code> when you need mutable properties:</p> <pre><code>class Counter(var value: Int) {\n}\n\nvar c = Counter(0)\nc.value = 10  // OK: var properties are mutable</code></pre> <p>Additional constructors can delegate to the primary one:</p> <pre><code>class Point(let x: Int, let y: Int) {\n    constructor(tuple: (Int, Int)) : this(tuple[0], tuple[1])\n}</code></pre>"},{"location":"en/guide/classes/#constructor-without-parameters","title":"Constructor Without Parameters","text":"<pre><code>class Counter(var value: Int = 0) {\n    fn increment() {\n        this.value += 1\n    }\n\n    fn get() -&gt; Int {\n        return this.value\n    }\n}\n\nvar c = Counter()\nc.increment()\nc.increment()\nprint(c.get())  // 2</code></pre>"},{"location":"en/guide/classes/#the-this-reference","title":"The <code>this</code> Reference","text":"<p><code>this</code> references the current instance:</p> <pre><code>class Circle(var radius: Float) {\n    fn area() -&gt; Float {\n        return 3.14159 * this.radius * this.radius\n    }\n\n    fn perimeter() -&gt; Float {\n        return 2 * 3.14159 * this.radius\n    }\n\n    fn scale(factor: Float) {\n        this.radius = this.radius * factor\n    }\n}\n\nvar circle = Circle(5.0)\nprint(circle.area())       // 78.53975\nprint(circle.perimeter())  // 31.4159\n\ncircle.scale(2.0)\nprint(circle.radius)       // 10</code></pre>"},{"location":"en/guide/classes/#static-members-and-blocks","title":"Static Members and Blocks","text":"<p>Use <code>static</code> to define class-level fields, methods, and initialization blocks. Static members are accessed on the class itself, not on instances.</p> <pre><code>class Config {\n    static let version = \"1.0\"\n    static var counter = 0\n\n    static fn bump() {\n        Config.counter = Config.counter + 1\n    }\n\n    static {\n        Config.bump()\n    }\n}\n\nprint(Config.version)  // \"1.0\"\nprint(Config.counter)  // 1</code></pre>"},{"location":"en/guide/classes/#nested-and-inner-classes","title":"Nested and Inner Classes","text":"<p>Use <code>nested class</code> for static nested types and <code>inner class</code> when you need access to the outer instance. Inner class instances store the outer instance in <code>this.__outer</code>.</p> <pre><code>class Outer(var value) {\n    nested class StaticLabel {\n        fn label() {\n            return \"static\"\n        }\n    }\n\n    inner class InnerValue {\n        fn outerValue() {\n            return this.__outer.value\n        }\n    }\n\n    fn makeInner() {\n        return this.InnerValue()\n    }\n}\n\nvar s = Outer.StaticLabel()\nvar o = Outer(10)\nvar i = o.makeInner()\nprint(i.outerValue())  // 10</code></pre> <p>You can also construct an inner class explicitly by passing the outer instance first:</p> <pre><code>var o = Outer(10)\nvar i = Outer.InnerValue(o)</code></pre> <p>Outside the class, use the explicit outer-argument form so the compiler can resolve the class unambiguously.</p> <p>When you already have an instance, you can also call <code>o.InnerValue()</code> (inner classes only).</p>"},{"location":"en/guide/classes/#instantiating-inner-classes-from-outer-instances","title":"Instantiating Inner Classes from Outer Instances","text":"<p>When you call <code>o.InnerValue()</code> on an existing outer instance, the compiler uses the same runtime helper as the interpreter to pass <code>o</code> along as the hidden <code>this.__outer</code> reference. This keeps <code>o.InnerValue()</code> behavior consistent between interpreted and compiled code, so the outer instance is always captured automatically.</p>"},{"location":"en/guide/classes/#properties","title":"Properties","text":""},{"location":"en/guide/classes/#accessing-properties","title":"Accessing Properties","text":"<pre><code>class Point(let x: Int, let y: Int) {\n}\n\nvar p = Point(3, 4)\nprint(p.x)  // 3\nprint(p.y)  // 4</code></pre>"},{"location":"en/guide/classes/#modifying-properties","title":"Modifying Properties","text":"<p>Use <code>var</code> for mutable properties:</p> <pre><code>class Point(var x: Int, var y: Int) {\n}\n\nvar p = Point(0, 0)\np.x = 10\np.y = 20\nprint(p.x)  // 10\nprint(p.y)  // 20</code></pre>"},{"location":"en/guide/classes/#dynamic-properties","title":"Dynamic Properties","text":"<p>You can add properties after creation:</p> <pre><code>class Object(var name: String = \"object\") {\n}\n\nvar obj = Object()\nobj.color = \"red\"       // New property\nobj.size = \"large\"      // Another property\n\nprint(obj.color)  // red\nprint(obj.size)   // large</code></pre>"},{"location":"en/guide/classes/#methods","title":"Methods","text":""},{"location":"en/guide/classes/#methods-with-return","title":"Methods with Return","text":"<pre><code>class Calculator(var memory: Int = 0) {\n    fn add(a: Int, b: Int) -&gt; Int {\n        return a + b\n    }\n\n    fn store(value: Int) {\n        this.memory = value\n    }\n\n    fn recall() -&gt; Int {\n        return this.memory\n    }\n}\n\nvar calc = Calculator()\nprint(calc.add(5, 3))  // 8\n\ncalc.store(100)\nprint(calc.recall())   // 100</code></pre>"},{"location":"en/guide/classes/#methods-that-modify-state","title":"Methods that Modify State","text":"<pre><code>class BankAccount(var balance: Float) {\n    fn deposit(amount: Float) {\n        this.balance += amount\n    }\n\n    fn withdraw(amount: Float) -&gt; Bool {\n        if amount &gt; this.balance {\n            print(\"Insufficient funds\")\n            return false\n        }\n        this.balance -= amount\n        return true\n    }\n\n    fn check() -&gt; Float {\n        return this.balance\n    }\n}\n\nvar account = BankAccount(1000.0)\naccount.deposit(500.0)\nprint(account.check())  // 1500\n\naccount.withdraw(200.0)\nprint(account.check())  // 1300</code></pre>"},{"location":"en/guide/classes/#inheritance","title":"Inheritance","text":"<p>Use <code>:</code> to inherit from another class:</p> <pre><code>class Animal(var name: String) {\n    fn speak() {\n        print(this.name + \" makes a sound\")\n    }\n}\n\nclass Dog(var name: String, var breed: String) : Animal(name) {\n    fn speak() {\n        print(this.name + \" barks\")\n    }\n}\n\nclass Cat(var name: String) : Animal(name) {\n    fn speak() {\n        print(this.name + \" meows\")\n    }\n}\n\nvar fido = Dog(\"Fido\", \"Labrador\")\nvar michi = Cat(\"Michi\")\n\nfido.speak()   // Fido barks\nmichi.speak()  // Michi meows</code></pre>"},{"location":"en/guide/classes/#the-super-keyword","title":"The <code>super</code> Keyword","text":"<p><code>super</code> allows accessing parent class methods:</p>"},{"location":"en/guide/classes/#in-the-constructor","title":"In the Constructor","text":"<pre><code>class Vehicle(var brand: String, var model: String) {\n    fn describe() -&gt; String {\n        return this.brand + \" \" + this.model\n    }\n}\n\nclass Car(var brand: String, var model: String, var doors: Int) : Vehicle(brand, model) {\n    fn describe() -&gt; String {\n        var base = super.describe()  // Call parent method\n        return base + \" (\" + str(this.doors) + \" doors)\"\n    }\n}\n\nvar car = Car(\"Toyota\", \"Corolla\", 4)\nprint(car.describe())  // Toyota Corolla (4 doors)</code></pre>"},{"location":"en/guide/classes/#in-methods","title":"In Methods","text":"<pre><code>class Employee(var name: String, var salary: Float) {\n    fn calculateBonus() -&gt; Float {\n        return this.salary * 0.10\n    }\n}\n\nclass Manager(var name: String, var salary: Float, var department: String) : Employee(name, salary) {\n    fn calculateBonus() -&gt; Float {\n        var baseBonus = super.calculateBonus()  // 10%\n        return baseBonus * 2  // Managers: 20%\n    }\n}\n\nvar emp = Employee(\"Ana\", 30000.0)\nvar mgr = Manager(\"Carlos\", 50000.0, \"Sales\")\n\nprint(emp.calculateBonus())  // 3000\nprint(mgr.calculateBonus())  // 10000</code></pre>"},{"location":"en/guide/classes/#polymorphism","title":"Polymorphism","text":"<p>Objects of different classes can be treated uniformly:</p> <pre><code>class Shape {\n    fn area() -&gt; Float {\n        return 0.0\n    }\n}\n\nclass Square(var side: Float) : Shape {\n    fn area() -&gt; Float {\n        return this.side * this.side\n    }\n}\n\nclass Circle(var radius: Float) : Shape {\n    fn area() -&gt; Float {\n        return 3.14159 * this.radius * this.radius\n    }\n}\n\n// Function that works with any shape\nfn totalArea(shapes: List[Shape]) -&gt; Float {\n    var total = 0.0\n\n    for shape in shapes {\n        total += shape.area()\n    }\n\n    return total\n}\n\nvar shapes = [\n    Square(5.0),\n    Circle(3.0)\n]\n\nprint(totalArea(shapes))  // 53.27431</code></pre>"},{"location":"en/guide/classes/#methods-with-short-syntax","title":"Methods with Short Syntax","text":"<p>You can use single-expression syntax in methods:</p> <pre><code>class Math {\n    fn square(x: Int) -&gt; Int = x * x\n    fn cube(x: Int) -&gt; Int = x * x * x\n    fn double(x: Int) -&gt; Int = x * 2\n    fn average(a: Int, b: Int) -&gt; Int = (a + b) / 2\n}\n\nvar m = Math()\nprint(m.square(4))      // 16\nprint(m.cube(3))        // 27\nprint(m.average(10, 20)) // 15</code></pre>"},{"location":"en/guide/classes/#common-patterns","title":"Common Patterns","text":""},{"location":"en/guide/classes/#builder","title":"Builder","text":"<pre><code>class PersonBuilder(var name: String = \"\", var age: Int = 0, var city: String = \"\") {\n    fn withName(name: String) -&gt; PersonBuilder {\n        this.name = name\n        return this\n    }\n\n    fn withAge(age: Int) -&gt; PersonBuilder {\n        this.age = age\n        return this\n    }\n\n    fn withCity(city: String) -&gt; PersonBuilder {\n        this.city = city\n        return this\n    }\n\n    fn build() -&gt; Dict[String, Any] {\n        return {\n            \"name\": this.name,\n            \"age\": this.age,\n            \"city\": this.city\n        }\n    }\n}\n\nvar person = PersonBuilder()\n    .withName(\"Ana\")\n    .withAge(25)\n    .withCity(\"Madrid\")\n    .build()\n\nprint(person)</code></pre>"},{"location":"en/guide/classes/#composition","title":"Composition","text":"<pre><code>class Engine(var power: Int, var running: Bool = false) {\n    fn start() {\n        this.running = true\n        print(\"Engine started\")\n    }\n\n    fn stop() {\n        this.running = false\n        print(\"Engine stopped\")\n    }\n}\n\nclass Car {\n    constructor(brand: String, enginePower: Int) {\n        this.brand = brand\n        this.engine = Engine(enginePower)  // Composition\n    }\n\n    fn start() {\n        print(\"Starting \" + this.brand)\n        this.engine.start()\n    }\n\n    fn stop() {\n        this.engine.stop()\n        print(this.brand + \" stopped\")\n    }\n}\n\nvar car = Car(\"Toyota\", 150)\ncar.start()\n// Starting Toyota\n// Engine started</code></pre>"},{"location":"en/guide/classes/#traits","title":"Traits","text":"<p>Traits define shared behavior that classes can implement. They're similar to interfaces but can have default implementations.</p>"},{"location":"en/guide/classes/#defining-a-trait","title":"Defining a Trait","text":"<pre><code>trait Describable {\n    fn describe() -&gt; String\n}</code></pre>"},{"location":"en/guide/classes/#implementing-a-trait","title":"Implementing a Trait","text":"<p>Use <code>:</code> to implement traits (same syntax as inheritance):</p> <pre><code>class Person(var name: String, var age: Int) : Describable {\n    fn describe() -&gt; String {\n        return \"Person: \" + this.name + \", \" + str(this.age) + \" years old\"\n    }\n}\n\nvar p = Person(\"Ana\", 25)\nprint(p.describe())  // Person: Ana, 25 years old</code></pre>"},{"location":"en/guide/classes/#default-implementations","title":"Default Implementations","text":"<p>Traits can provide default implementations:</p> <pre><code>trait Greetable {\n    fn greet() {\n        print(\"Hello, I am \" + this.name)\n    }\n}\n\nclass Student(var name: String) : Greetable {\n    // Uses default greet() implementation\n}\n\nvar s = Student(\"Luis\")\ns.greet()  // Hello, I am Luis</code></pre>"},{"location":"en/guide/classes/#trait-inheritance","title":"Trait Inheritance","text":"<p>Traits can extend other traits:</p> <pre><code>trait Walkable {\n    fn walk()\n}\n\ntrait Runner : Walkable {\n    fn run()\n}\n\n// Classes implementing Runner must implement both walk() and run()\nclass Athlete(var name: String) : Runner {\n    fn walk() {\n        print(this.name + \" is walking\")\n    }\n\n    fn run() {\n        print(this.name + \" is running\")\n    }\n}</code></pre>"},{"location":"en/guide/classes/#multiple-traits","title":"Multiple Traits","text":"<p>Classes can implement multiple traits:</p> <pre><code>trait Printable {\n    fn toPrint() -&gt; String\n}\n\ntrait Comparable {\n    fn compare(other: Any) -&gt; Int\n}\n\nclass Value(var n: Int) : Printable, Comparable {\n    fn toPrint() -&gt; String {\n        return \"Value(\" + str(this.n) + \")\"\n    }\n\n    fn compare(other: Any) -&gt; Int {\n        return this.n - other.n\n    }\n}</code></pre>"},{"location":"en/guide/classes/#class-inheritance-with-traits","title":"Class Inheritance with Traits","text":"<p>When inheriting from a class and implementing traits, the class comes first:</p> <pre><code>class Animal(var name: String) {\n    fn speak() {\n        print(this.name + \" makes a sound\")\n    }\n}\n\ntrait Flyable {\n    fn fly()\n}\n\nclass Bird(var name: String) : Animal(name), Flyable {\n    fn fly() {\n        print(this.name + \" is flying\")\n    }\n}\n\nvar b = Bird(\"Tweety\")\nb.speak()  // Tweety makes a sound\nb.fly()    // Tweety is flying</code></pre>"},{"location":"en/guide/classes/#see-also","title":"See Also","text":"<ul> <li>Functions</li> <li>Extensions</li> <li>Advanced Features</li> <li>Keywords</li> </ul>"},{"location":"en/guide/collections/","title":"Lists and Dictionaries","text":"<p>Language: Espa\u00f1ol | English</p> <p>Crespi provides three collection types: lists (arrays), tuples, and dictionaries (maps).</p>"},{"location":"en/guide/collections/#lists","title":"Lists","text":"<p>Lists are ordered collections that can contain elements of any type.</p>"},{"location":"en/guide/collections/#creating-lists","title":"Creating Lists","text":"<pre><code>// Empty list\nvar empty = []\n\n// List with elements\nvar numbers = [1, 2, 3, 4, 5]\nvar names = [\"Ana\", \"Luis\", \"Maria\"]\n\n// Mixed list\nvar mixed = [1, \"two\", true, null, [1, 2]]</code></pre>"},{"location":"en/guide/collections/#accessing-elements","title":"Accessing Elements","text":"<p>Indices start at 0:</p> <pre><code>var fruits = [\"apple\", \"orange\", \"pear\", \"grape\"]\n\nprint(fruits[0])   // apple (first)\nprint(fruits[1])   // orange\nprint(fruits[3])   // grape (last)</code></pre>"},{"location":"en/guide/collections/#negative-indices","title":"Negative Indices","text":"<p>Use negative indices to access from the end:</p> <pre><code>var fruits = [\"apple\", \"orange\", \"pear\", \"grape\"]\n\nprint(fruits[-1])  // grape (last)\nprint(fruits[-2])  // pear (second to last)\nprint(fruits[-4])  // apple (first)</code></pre>"},{"location":"en/guide/collections/#modifying-elements","title":"Modifying Elements","text":"<pre><code>var numbers = [10, 20, 30]\n\nnumbers[0] = 100\nnumbers[2] = 300\n\nprint(numbers)  // [100, 20, 300]</code></pre>"},{"location":"en/guide/collections/#length","title":"Length","text":"<pre><code>var list = [1, 2, 3, 4, 5]\nprint(list.length())  // 5\n\nvar empty = []\nprint(empty.length())  // 0</code></pre>"},{"location":"en/guide/collections/#tuples","title":"Tuples","text":"<p>Tuples are fixed-size ordered collections. They use parentheses and commas; a single-element tuple requires a trailing comma.</p> <pre><code>var point = (3, 4)\nvar single = (1,)\n\nprint(point[0])       // 3\nprint(point[-1])      // 4\nprint(point.length())  // 2</code></pre> <p>Tuples are immutable, so element assignment is not allowed.</p>"},{"location":"en/guide/collections/#list-operations","title":"List Operations","text":"<p>List mutation requires a <code>var</code> binding. Lists stored in <code>let</code> are immutable.</p>"},{"location":"en/guide/collections/#adding-elements","title":"Adding Elements","text":"<p><code>list.push(value)</code> appends to the end:</p> <pre><code>var numbers = [1, 2, 3]\n\nnumbers.push(4)\nnumbers.push(5)\n\nprint(numbers)  // [1, 2, 3, 4, 5]</code></pre>"},{"location":"en/guide/collections/#removing-elements","title":"Removing Elements","text":"<p><code>list.pop()</code> removes and returns the last element:</p> <pre><code>var numbers = [1, 2, 3, 4, 5]\n\nvar last = numbers.pop()\nprint(last)     // 5\nprint(numbers)  // [1, 2, 3, 4]</code></pre>"},{"location":"en/guide/collections/#checking-content","title":"Checking Content","text":"<p><code>list.contains(value)</code> checks if an element exists:</p> <pre><code>var fruits = [\"apple\", \"orange\", \"pear\"]\n\nprint(fruits.contains(\"orange\"))  // true\nprint(fruits.contains(\"grape\"))   // false</code></pre>"},{"location":"en/guide/collections/#iterating-over-lists","title":"Iterating Over Lists","text":""},{"location":"en/guide/collections/#for-each-loop","title":"For-Each Loop","text":"<pre><code>var colors = [\"red\", \"green\", \"blue\"]\n\nfor color in colors {\n    print(\"Color: \" + color)\n}\n// Color: red\n// Color: green\n// Color: blue</code></pre>"},{"location":"en/guide/collections/#with-index","title":"With Index","text":"<pre><code>var elements = [\"a\", \"b\", \"c\"]\nvar i = 0\n\nfor elem in elements {\n    print(str(i) + \": \" + elem)\n    i += 1\n}\n// 0: a\n// 1: b\n// 2: c</code></pre>"},{"location":"en/guide/collections/#dictionaries","title":"Dictionaries","text":"<p>Dictionaries store key-value pairs. Keys are always text.</p>"},{"location":"en/guide/collections/#creating-dictionaries","title":"Creating Dictionaries","text":"<pre><code>// Empty dictionary\nvar empty = {}\n\n// Dictionary with data\nvar person = {\n    \"name\": \"Ana\",\n    \"age\": 25,\n    \"city\": \"Madrid\"\n}\n\n// Values of any type\nvar config = {\n    \"debug\": true,\n    \"max_items\": 100,\n    \"users\": [\"admin\", \"user\"]\n}</code></pre>"},{"location":"en/guide/collections/#accessing-values","title":"Accessing Values","text":"<pre><code>var person = {\n    \"name\": \"Ana\",\n    \"age\": 25\n}\n\nprint(person[\"name\"])  // Ana\nprint(person[\"age\"])   // 25</code></pre>"},{"location":"en/guide/collections/#modifying-values","title":"Modifying Values","text":"<p>Dictionary mutation requires a <code>var</code> binding. Dictionaries stored in <code>let</code> are immutable.</p> <pre><code>var person = {\n    \"name\": \"Ana\",\n    \"age\": 25\n}\n\n// Modify existing\nperson[\"age\"] = 26\n\n// Add new\nperson[\"city\"] = \"Barcelona\"\n\nprint(person)\n// {name: Ana, age: 26, city: Barcelona}</code></pre>"},{"location":"en/guide/collections/#dictionary-operations","title":"Dictionary Operations","text":""},{"location":"en/guide/collections/#getting-keys","title":"Getting Keys","text":"<pre><code>var person = {\n    \"name\": \"Ana\",\n    \"age\": 25,\n    \"city\": \"Madrid\"\n}\n\nvar k = person.keys()\nprint(k)  // [name, age, city]</code></pre>"},{"location":"en/guide/collections/#getting-values","title":"Getting Values","text":"<pre><code>var grades = {\n    \"math\": 90,\n    \"physics\": 85,\n    \"chemistry\": 78\n}\n\nvar v = grades.values()\nprint(v)  // [90, 85, 78]</code></pre>"},{"location":"en/guide/collections/#checking-keys","title":"Checking Keys","text":"<p><code>dict.contains(key)</code> checks if a key exists:</p> <pre><code>var config = {\n    \"debug\": true,\n    \"timeout\": 5000\n}\n\nprint(config.contains(\"debug\"))    // true\nprint(config.contains(\"verbose\"))  // false</code></pre>"},{"location":"en/guide/collections/#iterating-over-dictionaries","title":"Iterating Over Dictionaries","text":""},{"location":"en/guide/collections/#by-keys","title":"By Keys","text":"<pre><code>var person = {\n    \"name\": \"Ana\",\n    \"age\": 25,\n    \"city\": \"Madrid\"\n}\n\nfor key in person.keys() {\n    print(key + \": \" + str(person[key]))\n}\n// name: Ana\n// age: 25\n// city: Madrid</code></pre>"},{"location":"en/guide/collections/#by-values","title":"By Values","text":"<pre><code>var prices = {\n    \"apple\": 1.50,\n    \"orange\": 2.00,\n    \"pear\": 1.75\n}\n\nvar total = 0\nfor price in prices.values() {\n    total += price\n}\nprint(\"Total: \" + str(total))  // Total: 5.25</code></pre>"},{"location":"en/guide/collections/#nested-lists","title":"Nested Lists","text":"<pre><code>// 3x3 matrix\nvar matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n\n// Access\nprint(matrix[0][0])  // 1\nprint(matrix[1][1])  // 5\nprint(matrix[2][2])  // 9\n\n// Iterate\nfor row in matrix {\n    for cell in row {\n        print(cell)\n    }\n}</code></pre>"},{"location":"en/guide/collections/#nested-dictionaries","title":"Nested Dictionaries","text":"<pre><code>var company = {\n    \"name\": \"TechCorp\",\n    \"employees\": {\n        \"manager\": {\n            \"name\": \"Ana\",\n            \"salary\": 50000\n        },\n        \"developer\": {\n            \"name\": \"Luis\",\n            \"salary\": 35000\n        }\n    }\n}\n\n// Nested access\nprint(company[\"employees\"][\"manager\"][\"name\"])  // Ana</code></pre>"},{"location":"en/guide/collections/#common-patterns","title":"Common Patterns","text":""},{"location":"en/guide/collections/#find-in-list","title":"Find in List","text":"<pre><code>fn [T] find_index(list: List[T], target: T) -&gt; Int {\n    var i = 0\n\n    for item in list {\n        if item == target {\n            return i\n        }\n        i += 1\n    }\n\n    return -1  // Not found\n}\n\nvar fruits = [\"apple\", \"orange\", \"pear\"]\nprint(find_index(fruits, \"orange\"))  // 1\nprint(find_index(fruits, \"grape\"))   // -1</code></pre>"},{"location":"en/guide/collections/#count-frequencies","title":"Count Frequencies","text":"<pre><code>fn [T] count_frequencies(list: List[T]) -&gt; Dict[String, Int] {\n    var frequencies = {}\n\n    for item in list {\n        var key = str(item)\n        if frequencies.contains(key) {\n            frequencies[key] += 1\n        } else {\n            frequencies[key] = 1\n        }\n    }\n\n    return frequencies\n}\n\nvar votes = [\"A\", \"B\", \"A\", \"C\", \"B\", \"A\"]\nprint(count_frequencies(votes))\n// {A: 3, B: 2, C: 1}</code></pre>"},{"location":"en/guide/collections/#stack","title":"Stack","text":"<pre><code>var stack = []\n\n// Push\nstack.push(\"first\")\nstack.push(\"second\")\nstack.push(\"third\")\n\n// Pop\nprint(stack.pop())  // third\nprint(stack.pop())  // second\nprint(stack.pop())  // first</code></pre>"},{"location":"en/guide/collections/#see-also","title":"See Also","text":"<ul> <li>Data Types</li> <li>Built-in Functions</li> <li>Control Flow</li> </ul>"},{"location":"en/guide/compiler/","title":"Native Compiler","text":"<p>Language: Espa\u00f1ol | English</p> <p>The Crespi compiler (<code>crespic</code>) generates native executables from your code. It's ideal for distribution and maximum performance.</p>"},{"location":"en/guide/compiler/#quick-start","title":"Quick Start","text":"<pre><code># Compile a program\ncrespic program.crespi\n\n# Run the generated binary\n./program</code></pre>"},{"location":"en/guide/compiler/#basic-usage","title":"Basic Usage","text":""},{"location":"en/guide/compiler/#compile","title":"Compile","text":"<pre><code>crespic my_program.crespi</code></pre> <p>This generates an executable with the same name as the source file (without extension).</p>"},{"location":"en/guide/compiler/#type-check-optional","title":"Type Check (Optional)","text":"<pre><code>crespic --check my_program.crespi</code></pre> <p>Runs the static type checker before compiling. The compiler exits on type errors.</p>"},{"location":"en/guide/compiler/#custom-output-name","title":"Custom Output Name","text":"<pre><code>crespic my_program.crespi -o application\n./application</code></pre>"},{"location":"en/guide/compiler/#complete-example","title":"Complete Example","text":"<pre><code># Create program\necho 'print(\"Hello from native code!\")' &gt; hello.crespi\n\n# Compile\ncrespic hello.crespi\n\n# Run\n./hello\n# Output: Hello from native code!</code></pre>"},{"location":"en/guide/compiler/#cli-reference","title":"CLI Reference","text":"Option Description <code>&lt;file&gt;</code> Source file to compile <code>-o, --output &lt;name&gt;</code> Output executable name <code>--check</code> Run the type checker before compiling <code>-L &lt;library&gt;</code> Link an external static library (can be used multiple times) <code>-O0</code> No optimization (default) <code>-O1</code> Basic optimization (includes <code>@inline</code> decorated functions) <code>-O2</code> Full optimization (auto-inlines small functions) <code>--help</code> Show help <code>--version</code> Show version"},{"location":"en/guide/compiler/#experimental-native-abi-backend","title":"Experimental Native ABI Backend","text":"<p>The <code>native-abi</code> Cargo feature enables an experimental backend that lowers typed numeric code to native ABI signatures. For now it supports <code>Int</code>, <code>Double</code>, <code>Bool</code>, and <code>print()</code> for those types.</p> <pre><code>cargo run --bin crespic --features native-abi -- examples/simple_scripts/native_abi_demo.crespi -o /tmp/crespi_native_abi_demo\n/tmp/crespi_native_abi_demo</code></pre>"},{"location":"en/guide/compiler/#supported-features","title":"Supported Features","text":"<p>The compiler supports most language features:</p> <ul> <li>\u2705 Variables and constants</li> <li>\u2705 Primitive types: integers, decimals, text, booleans</li> <li>\u2705 Arrays: literals, indexing, <code>list.length()</code>, <code>list.push()</code>, <code>list.pop()</code></li> <li>\u2705 Dictionaries: literals, indexing, <code>dict.keys()</code>, <code>dict.values()</code>, <code>dict.contains()</code></li> <li>\u2705 Control flow: <code>if</code>, <code>while</code>, <code>for...in</code>, <code>break</code>, <code>continue</code></li> <li>\u2705 Functions: definitions, recursion, default parameters</li> <li>\u2705 Closures with variable capture</li> <li>\u2705 Classes: <code>class</code>, inheritance (<code>:</code>), <code>super</code></li> <li>\u2705 Decorators: <code>@memoize</code>, <code>@inline</code></li> <li>\u2705 Built-in functions: <code>print()</code>, <code>read()</code>, <code>typeof()</code>, <code>str()</code>, <code>int()</code>, <code>float()</code>, <code>memoize()</code>; collection and string helpers are methods (for example <code>list.map()</code>, <code>text.trim()</code>, <code>dict.keys()</code>).</li> <li>\u2705 Extern functions: Call native Rust/C libraries via FFI</li> </ul>"},{"location":"en/guide/compiler/#extern-functions-ffi","title":"Extern Functions (FFI)","text":"<p>Crespi supports calling external native functions from Rust or C libraries using the <code>extern fn</code> declaration.</p>"},{"location":"en/guide/compiler/#1-declare-in-crespi","title":"1. Declare in Crespi","text":"<pre><code>extern fn my_add(a: Int, b: Int) -&gt; Int\nextern fn my_sin(x: Double) -&gt; Double\n\n// Bind to a different native symbol name\n#[link_name = \"my_add_impl\"]\nextern fn my_add(a: Int, b: Int) -&gt; Int\n\nfn main() {\n    print(my_add(10, 32))  // Output: 42\n    print(my_sin(1.57))    // Output: ~1.0\n}</code></pre>"},{"location":"en/guide/compiler/#2-implement-in-rust","title":"2. Implement in Rust","text":"<pre><code>// lib.rs\n#[no_mangle]\npub extern \"C\" fn my_add(a: i64, b: i64) -&gt; i64 {\n    a + b\n}\n\n#[no_mangle]\npub extern \"C\" fn my_sin(x: f64) -&gt; f64 {\n    x.sin()\n}</code></pre>"},{"location":"en/guide/compiler/#3-build-and-link","title":"3. Build and Link","text":"<pre><code># Compile Rust library\nrustc --crate-type=staticlib -o libmymath.a lib.rs\n\n# Compile Crespi with the library\ncrespic program.crespi -L libmymath.a -o program\n\n# Run\n./program</code></pre>"},{"location":"en/guide/compiler/#type-mapping","title":"Type Mapping","text":"Crespi Rust Notes <code>Int</code> <code>i64</code> 64-bit signed integer <code>Double</code> <code>f64</code> 64-bit floating point <code>Float</code> <code>f32</code> 32-bit floating point <code>Bool</code> <code>bool</code> Boolean value <code>Unit</code> <code>()</code> No return value"},{"location":"en/guide/compiler/#entry-point","title":"Entry Point","text":"<p>The compiler looks for an entry point in two ways:</p>"},{"location":"en/guide/compiler/#1-explicit-main-function","title":"1. Explicit <code>main()</code> function","text":"<pre><code>fn main() {\n    print(\"Hello, World!\")\n}</code></pre>"},{"location":"en/guide/compiler/#2-top-level-code-implicit","title":"2. Top-level code (implicit)","text":"<pre><code>// Top-level code runs automatically\nprint(\"Hello, World!\")\n\nfn helper() {\n    print(\"This is a helper function\")\n}</code></pre> <p>In the second case, the compiler generates a synthetic <code>main()</code> function containing the top-level code.</p>"},{"location":"en/guide/compiler/#how-it-works","title":"How It Works","text":"<pre><code>Source Code (.crespi)\n    \u2193\nLexer/Scanner (tokenization)\n    \u2193\nParser (AST generation)\n    \u2193\nLowerer (AST \u2192 HIR)\n    \u2193\nCompiler (HIR \u2192 LLVM IR)\n    \u2193\nCode Generator (machine code)\n    \u2193\nLinker (links with libcrespi_runtime.a)\n    \u2193\nNative Executable</code></pre>"},{"location":"en/guide/compiler/#optimization-levels","title":"Optimization Levels","text":"<p>The compiler supports three optimization levels:</p>"},{"location":"en/guide/compiler/#-o0-default","title":"<code>-O0</code> (Default)","text":"<p>No optimization. Code is compiled directly without any transformations.</p>"},{"location":"en/guide/compiler/#-o1-basic","title":"<code>-O1</code> (Basic)","text":"<p>Basic optimizations including: - Constant folding - Function inlining for <code>@inline</code> decorated functions - LLVM pass pipeline at <code>-O1</code> (including <code>alwaysinline</code> attributes)</p> <pre><code>@inline\nfn double(x) { return x * 2 }\n\nfn main() {\n    // At -O1, this call is replaced with: result = 21 * 2\n    var result = double(21)\n    print(result)\n}</code></pre>"},{"location":"en/guide/compiler/#-o2-full","title":"<code>-O2</code> (Full)","text":"<p>Full optimizations including everything from <code>-O1</code> plus: - Auto-inlining of small functions (\u22645 statements) - More aggressive constant propagation - LLVM pass pipeline at <code>-O2</code> with inline hints for small functions</p> <p>Small, non-recursive functions are automatically inlined even without the <code>@inline</code> decorator.</p> <pre><code># Compile with full optimization\ncrespic -O2 program.crespi</code></pre>"},{"location":"en/guide/compiler/#implementation-note","title":"Implementation Note","text":"<p>The compiler codebase uses English identifiers and terminology. The Crespi language surface is English-first, with Spanish aliases provided via language packs.</p>"},{"location":"en/guide/compiler/#when-to-use-the-compiler","title":"When to Use the Compiler","text":"Use Case Recommendation Distributing applications \u2705 Compiler Maximum performance \u2705 Compiler Development and testing \u274c Use interpreter Interactive REPL \u274c Use interpreter"},{"location":"en/guide/compiler/#see-also","title":"See Also","text":"<ul> <li>Interpreter - Run code directly</li> <li>Variables - Data types and variables</li> <li>Classes - Object-oriented programming</li> </ul>"},{"location":"en/guide/control-flow/","title":"Control Flow","text":"<p>Language: Espa\u00f1ol | English</p> <p>Crespi provides structures to control the execution flow of your program.</p>"},{"location":"en/guide/control-flow/#conditionals","title":"Conditionals","text":""},{"location":"en/guide/control-flow/#basic-syntax-if","title":"Basic Syntax: <code>if</code>","text":"<p>Executes code only if a condition is true:</p> <pre><code>var age = 18\n\nif age &gt;= 18 {\n    print(\"Adult\")\n}</code></pre>"},{"location":"en/guide/control-flow/#with-alternative-else","title":"With Alternative: <code>else</code>","text":"<p>Executes alternative code if the condition is false:</p> <pre><code>var age = 16\n\nif age &gt;= 18 {\n    print(\"Adult\")\n} else {\n    print(\"Minor\")\n}\n// Output: Minor</code></pre>"},{"location":"en/guide/control-flow/#multiple-conditions","title":"Multiple Conditions","text":"<p>Chain several conditions with <code>else if</code>:</p> <pre><code>var grade = 75\n\nif grade &gt;= 90 {\n    print(\"Excellent\")\n} else if grade &gt;= 80 {\n    print(\"Good\")\n} else if grade &gt;= 70 {\n    print(\"Pass\")\n} else if grade &gt;= 60 {\n    print(\"Acceptable\")\n} else {\n    print(\"Fail\")\n}\n// Output: Pass</code></pre>"},{"location":"en/guide/control-flow/#nested-conditionals","title":"Nested Conditionals","text":"<p>You can nest conditionals:</p> <pre><code>var age = 25\nvar hasLicense = true\n\nif age &gt;= 18 {\n    if hasLicense {\n        print(\"Can drive\")\n    } else {\n        print(\"Needs license\")\n    }\n} else {\n    print(\"Too young to drive\")\n}</code></pre>"},{"location":"en/guide/control-flow/#logical-operators","title":"Logical Operators","text":"<p>Combine conditions with <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code>:</p> <pre><code>var age = 25\nvar isStudent = true\nvar hasDiscount = false\n\n// AND: both must be true\nif age &gt;= 18 &amp;&amp; isStudent {\n    print(\"Adult student\")\n}\n\n// OR: at least one must be true\nif isStudent || hasDiscount {\n    print(\"Discount applies\")\n}\n\n// NOT: inverts condition\nif !hasDiscount {\n    print(\"No previous discount\")\n}\n\n// Combinations\nif age &gt;= 18 &amp;&amp; (isStudent || hasDiscount) {\n    print(\"Adult with benefit\")\n}</code></pre>"},{"location":"en/guide/control-flow/#pattern-matching-when","title":"Pattern Matching (<code>when</code>)","text":"<p>Use <code>when</code> to match a value against patterns with destructuring:</p> <pre><code>var output = \"\"\n\nwhen [1, 2] {\n    is [a, b] =&gt; { output = \"$a-$b\" }\n    is {\"name\": n} =&gt; { output = n }\n    default =&gt; { output = \"other\" }\n}</code></pre> <p><code>default</code> is required to ensure exhaustive matching.</p> <p>Class instances can be matched by name and fields:</p> <pre><code>class Person(let name, let age) {\n}\n\nvar person = Person(\"Ana\", 30)\n\nwhen person {\n    is Person { name: n, age: e } =&gt; { print(\"$n-$e\") }\n    default =&gt; { print(\"no\") }\n}</code></pre>"},{"location":"en/guide/control-flow/#while-loop","title":"While Loop","text":""},{"location":"en/guide/control-flow/#basic-syntax","title":"Basic Syntax","text":"<p>Repeats while the condition is true:</p> <pre><code>var i = 0\n\nwhile i &lt; 5 {\n    print(i)\n    i += 1\n}\n// Output: 0, 1, 2, 3, 4</code></pre>"},{"location":"en/guide/control-flow/#countdown","title":"Countdown","text":"<pre><code>var count = 5\n\nwhile count &gt; 0 {\n    print(count)\n    count -= 1\n}\nprint(\"Liftoff!\")\n// Output: 5, 4, 3, 2, 1, Liftoff!</code></pre>"},{"location":"en/guide/control-flow/#infinite-loop-with-exit","title":"Infinite Loop with Exit","text":"<pre><code>var attempts = 0\n\nwhile true {\n    attempts += 1\n    print(\"Attempt \" + str(attempts))\n\n    if attempts &gt;= 3 {\n        break  // Exit the loop\n    }\n}\nprint(\"Done\")</code></pre>"},{"location":"en/guide/control-flow/#for-each-loop","title":"For-Each Loop","text":""},{"location":"en/guide/control-flow/#iterating-over-lists","title":"Iterating Over Lists","text":"<pre><code>var fruits = [\"apple\", \"orange\", \"pear\"]\n\nfor fruit in fruits {\n    print(\"I like \" + fruit)\n}\n// Output: I like apple, I like orange, I like pear</code></pre>"},{"location":"en/guide/control-flow/#iterating-over-text","title":"Iterating Over Text","text":"<pre><code>var word = \"Hello\"\n\nfor letter in word {\n    print(letter)\n}\n// Output: H, e, l, l, o</code></pre>"},{"location":"en/guide/control-flow/#iterating-with-index","title":"Iterating with Index","text":"<p>To get the index, use a counter:</p> <pre><code>var colors = [\"red\", \"green\", \"blue\"]\nvar i = 0\n\nfor color in colors {\n    print(str(i) + \": \" + color)\n    i += 1\n}\n// Output: 0: red, 1: green, 2: blue</code></pre>"},{"location":"en/guide/control-flow/#iterating-over-dictionaries","title":"Iterating Over Dictionaries","text":"<pre><code>var person = {\n    \"name\": \"Ana\",\n    \"age\": 25,\n    \"city\": \"Madrid\"\n}\n\nfor key in person.keys() {\n    print(key + \": \" + str(person[key]))\n}</code></pre>"},{"location":"en/guide/control-flow/#loop-control","title":"Loop Control","text":""},{"location":"en/guide/control-flow/#break","title":"<code>break</code>","text":"<p>Terminates the loop immediately:</p> <pre><code>var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nfor n in numbers {\n    if n == 5 {\n        break\n    }\n    print(n)\n}\n// Output: 1, 2, 3, 4</code></pre>"},{"location":"en/guide/control-flow/#continue","title":"<code>continue</code>","text":"<p>Skips to the next iteration:</p> <pre><code>var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nfor n in numbers {\n    if n % 2 == 0 {\n        continue  // Skip even numbers\n    }\n    print(n)\n}\n// Output: 1, 3, 5, 7, 9</code></pre>"},{"location":"en/guide/control-flow/#truthiness","title":"Truthiness","text":"<p>In Crespi, certain values evaluate to <code>false</code> in conditions:</p> Value Evaluation <code>false</code> False <code>0</code> False <code>0.0</code> False <code>\"\"</code> (empty text) False <code>[]</code> (empty list) False <code>null</code> False Everything else True <pre><code>// Check if list has elements\nvar list = [1, 2, 3]\nif list {\n    print(\"List has elements\")\n}\n\n// Check if text is not empty\nvar name = \"Ana\"\nif name {\n    print(\"Hello, \" + name)\n}\n\n// Check if value exists\nvar result = null\nif !result {\n    print(\"No result\")\n}</code></pre>"},{"location":"en/guide/control-flow/#common-patterns","title":"Common Patterns","text":""},{"location":"en/guide/control-flow/#search-in-list","title":"Search in List","text":"<pre><code>fn find(list, target) {\n    for item in list {\n        if item == target {\n            return item\n        }\n    }\n    return null\n}\n\nvar numbers = [10, 20, 30, 40]\nvar found = find(numbers, 30)\n\nif found != null {\n    print(\"Found: \" + str(found))\n} else {\n    print(\"Not found\")\n}</code></pre>"},{"location":"en/guide/control-flow/#filter-list","title":"Filter List","text":"<pre><code>fn filter_even(list) {\n    var result = []\n\n    for n in list {\n        if n % 2 == 0 {\n            result.push(n)\n        }\n    }\n\n    return result\n}\n\nvar numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(filter_even(numbers))  // [2, 4, 6, 8, 10]</code></pre>"},{"location":"en/guide/control-flow/#find-maximum","title":"Find Maximum","text":"<pre><code>fn maximum(list) {\n    if list.length() == 0 {\n        return null\n    }\n\n    var max = list[0]\n\n    for n in list {\n        if n &gt; max {\n            max = n\n        }\n    }\n\n    return max\n}\n\nprint(maximum([3, 7, 2, 9, 1]))  // 9</code></pre>"},{"location":"en/guide/control-flow/#multiplication-table","title":"Multiplication Table","text":"<pre><code>var n = 5\nvar i = 1\n\nwhile i &lt;= 10 {\n    print(str(n) + \" x \" + str(i) + \" = \" + str(n * i))\n    i += 1\n}</code></pre>"},{"location":"en/guide/control-flow/#see-also","title":"See Also","text":"<ul> <li>Variables and Constants</li> <li>Functions</li> <li>Operators</li> </ul>"},{"location":"en/guide/extensions/","title":"Extensions","text":"<p>Language: Espa\u00f1ol | English</p> <p>Extensions allow you to add new methods to existing types without modifying their original definition. This is similar to Swift's extension feature.</p>"},{"location":"en/guide/extensions/#basic-syntax","title":"Basic Syntax","text":"<p>Use the <code>extension</code> keyword followed by the type name:</p> <pre><code>extension Entero {\n    fn isEven() {\n        return this % 2 == 0\n    }\n}\n\nvar n = 10\nprint(n.isEven())  // true</code></pre> <p>You can also declare a single extension function inline:</p> <pre><code>fn Entero.isOdd() = this % 2 != 0\n\nprint((7).isOdd())  // true\nprint(isOdd(7))     // true (call as a plain function)</code></pre> <p>Extension functions are also exposed as plain functions that take the receiver as the first argument, which makes them easy to import and use in DSL-style code.</p>"},{"location":"en/guide/extensions/#extension-methods","title":"Extension Methods","text":"<p>Extension methods work like regular methods with access to <code>this</code>:</p> <pre><code>extension Texto {\n    fn reverse() {\n        var result = \"\"\n        var i = this.length() - 1\n        while i &gt;= 0 {\n            result = result + this.substring(i, i + 1)\n            i = i - 1\n        }\n        return result\n    }\n\n    fn repeatN(times) {\n        var result = \"\"\n        var i = 0\n        while i &lt; times {\n            result = result + this\n            i = i + 1\n        }\n        return result\n    }\n}\n\nvar text = \"Hello\"\nprint(text.reverse())      // \"olleH\"\nprint(\"ab\".repeatN(3))     // \"ababab\"</code></pre>"},{"location":"en/guide/extensions/#supported-types","title":"Supported Types","text":"<p>Extensions can be added to the following built-in runtime types (English names are canonical; language packs can provide aliases like <code>Texto</code>):</p> Type Name Description <code>Texto</code> String <code>Entero</code> Integer <code>Decimal</code> Float <code>Lista</code> Array/List <code>Diccionario</code> Dictionary/Map <code>Tupla</code> Tuple <code>Booleano</code> Boolean <p>You can also extend user-defined classes:</p> <pre><code>class Point(let x, let y)\n\nextension Point {\n    fn magnitude() {\n        return sqrt(this.x * this.x + this.y * this.y)\n    }\n}\n\nvar p = Point(3, 4)\nprint(p.magnitude())  // 5.0</code></pre>"},{"location":"en/guide/extensions/#integer-extensions","title":"Integer Extensions","text":"<pre><code>extension Entero {\n    fn isPositive() {\n        return this &gt; 0\n    }\n\n    fn square() {\n        return this * this\n    }\n\n    fn factorial() {\n        if this &lt;= 1 {\n            return 1\n        }\n        return this * (this - 1).factorial()\n    }\n}\n\nprint((5).square())      // 25\nprint((5).factorial())   // 120\nprint((-3).isPositive()) // false</code></pre>"},{"location":"en/guide/extensions/#float-extensions","title":"Float Extensions","text":"<pre><code>extension Decimal {\n    fn isWhole() {\n        return this == floor(this)\n    }\n\n    fn toPercentage() {\n        return str(this * 100) + \"%\"\n    }\n}\n\nprint((3.14).isWhole())      // false\nprint((4.0).isWhole())       // true\nprint((0.75).toPercentage()) // \"75%\"</code></pre>"},{"location":"en/guide/extensions/#list-extensions","title":"List Extensions","text":"<pre><code>extension Lista {\n    fn sum() {\n        var total = 0\n        for item in this {\n            total = total + item\n        }\n        return total\n    }\n\n    fn average() {\n        return this.sum() / this.length()\n    }\n\n    fn isEmpty() {\n        return this.length() == 0\n    }\n}\n\nvar numbers = [1, 2, 3, 4, 5]\nprint(numbers.sum())      // 15\nprint(numbers.average())  // 3\nprint([].isEmpty())       // true</code></pre>"},{"location":"en/guide/extensions/#multiple-extensions-for-same-type","title":"Multiple Extensions for Same Type","text":"<p>You can define multiple extension blocks for the same type:</p> <pre><code>extension Entero {\n    fn double() {\n        return this * 2\n    }\n}\n\nextension Entero {\n    fn triple() {\n        return this * 3\n    }\n}\n\nvar n = 5\nprint(n.double())  // 10\nprint(n.triple())  // 15</code></pre>"},{"location":"en/guide/extensions/#method-chaining","title":"Method Chaining","text":"<p>Extension methods can be chained:</p> <pre><code>extension Entero {\n    fn add(n) {\n        return this + n\n    }\n\n    fn multiply(n) {\n        return this * n\n    }\n}\n\nvar result = (2).add(3).multiply(4)\nprint(result)  // 20</code></pre>"},{"location":"en/guide/extensions/#extension-behavior","title":"Extension Behavior","text":"<ul> <li>Methods use <code>this</code> to access the receiver value</li> <li>Extensions are registered at parse time</li> <li>Multiple extensions for the same type are merged</li> <li>Instance methods take precedence over extension methods</li> <li>Extensions work in both the interpreter and native compilation</li> </ul>"},{"location":"en/guide/extensions/#see-also","title":"See Also","text":"<ul> <li>Classes and Objects</li> <li>Functions</li> <li>Generics</li> </ul>"},{"location":"en/guide/functions/","title":"Functions","text":"<p>Language: Espa\u00f1ol | English</p> <p>Functions in Crespi allow you to encapsulate and reuse code.</p>"},{"location":"en/guide/functions/#basic-declaration","title":"Basic Declaration","text":"<p>Use <code>fn</code> to define a function with type annotations:</p> <pre><code>fn greet() {\n    print(\"Hello!\")\n}\n\ngreet()  // Hello!</code></pre>"},{"location":"en/guide/functions/#with-parameters","title":"With Parameters","text":"<pre><code>fn greet(name: String) {\n    print(\"Hello, \" + name + \"!\")\n}\n\ngreet(\"Ana\")    // Hello, Ana!\ngreet(\"Carlos\") // Hello, Carlos!</code></pre>"},{"location":"en/guide/functions/#with-multiple-parameters","title":"With Multiple Parameters","text":"<pre><code>fn add(a: Int, b: Int) -&gt; Int {\n    return a + b\n}\n\nprint(add(3, 5))   // 8\nprint(add(10, 20)) // 30</code></pre>"},{"location":"en/guide/functions/#return-value","title":"Return Value","text":"<p>Use <code>return</code> to return a value. Specify the return type with <code>-&gt;</code>:</p> <pre><code>fn square(x: Int) -&gt; Int {\n    return x * x\n}\n\nvar r = square(5)\nprint(r)  // 25</code></pre>"},{"location":"en/guide/functions/#early-return","title":"Early Return","text":"<p><code>return</code> terminates the function immediately:</p> <pre><code>fn absolute(n: Int) -&gt; Int {\n    if n &lt; 0 {\n        return -n\n    }\n    return n\n}\n\nprint(absolute(-5))  // 5\nprint(absolute(3))   // 3</code></pre>"},{"location":"en/guide/functions/#no-explicit-return","title":"No Explicit Return","text":"<p>If there's no <code>return</code>, the function returns <code>null</code>:</p> <pre><code>fn greet(name: String) {\n    print(\"Hello, \" + name)\n}\n\nvar r = greet(\"Ana\")\nprint(r)  // null</code></pre>"},{"location":"en/guide/functions/#single-expression-syntax","title":"Single-Expression Syntax","text":"<p>For simple functions, use the short syntax with <code>fn</code> and <code>=</code>:</p> <pre><code>// Standard syntax\nfn double(x: Int) -&gt; Int {\n    return x * 2\n}\n\n// Short syntax (equivalent)\nfn double(x: Int) -&gt; Int = x * 2</code></pre>"},{"location":"en/guide/functions/#more-examples","title":"More Examples","text":"<pre><code>// Single expression\nfn square(x: Int) -&gt; Int = x * x\nfn triple(x: Int) -&gt; Int = x * 3\n\n// Multiple parameters\nfn sum(a: Int, b: Int) -&gt; Int = a + b\nfn average(a: Float, b: Float) -&gt; Float = (a + b) / 2.0\n\n// No parameters\nfn getPi() -&gt; Float = 3.14159\nfn greeting() -&gt; String = \"Hello world\"\n\n// Usage\nprint(square(4))            // 16\nprint(sum(10, 5))           // 15\nprint(average(80.0, 90.0))  // 85.0</code></pre>"},{"location":"en/guide/functions/#default-parameters","title":"Default Parameters","text":"<p>You can assign default values to parameters:</p> <pre><code>fn greet(name: String = \"World\") {\n    print(\"Hello, \" + name)\n}\n\ngreet()       // Hello, World\ngreet(\"Ana\")  // Hello, Ana</code></pre>"},{"location":"en/guide/functions/#multiple-parameters-with-defaults","title":"Multiple Parameters with Defaults","text":"<pre><code>fn createMessage(text: String, repetitions: Int = 1, separator: String = \" \") -&gt; String {\n    var message = \"\"\n    var i = 0\n\n    while i &lt; repetitions {\n        if i &gt; 0 {\n            message = message + separator\n        }\n        message = message + text\n        i += 1\n    }\n\n    return message\n}\n\nprint(createMessage(\"Hello\"))           // Hello\nprint(createMessage(\"Hello\", 3))        // Hello Hello Hello\nprint(createMessage(\"Hello\", 3, \"-\"))   // Hello-Hello-Hello</code></pre>"},{"location":"en/guide/functions/#functions-as-values","title":"Functions as Values","text":"<p>Functions are first-class values:</p>"},{"location":"en/guide/functions/#assign-to-variables","title":"Assign to Variables","text":"<pre><code>fn duplicate(x: Int) -&gt; Int {\n    return x * 2\n}\n\nvar operation = duplicate\nprint(operation(5))  // 10</code></pre>"},{"location":"en/guide/functions/#pass-as-argument","title":"Pass as Argument","text":"<pre><code>fn apply(f: (Int) -&gt; Int, value: Int) -&gt; Int {\n    return f(value)\n}\n\nfn square(x: Int) -&gt; Int = x * x\nfn cube(x: Int) -&gt; Int = x * x * x\n\nprint(apply(square, 4))  // 16\nprint(apply(cube, 3))    // 27</code></pre>"},{"location":"en/guide/functions/#return-functions","title":"Return Functions","text":"<pre><code>fn createMultiplier(factor: Int) -&gt; (Int) -&gt; Int {\n    fn multiply(x: Int) -&gt; Int {\n        return x * factor\n    }\n    return multiply\n}\n\nvar double = createMultiplier(2)\nvar triple = createMultiplier(3)\n\nprint(double(5))   // 10\nprint(triple(5))   // 15</code></pre>"},{"location":"en/guide/functions/#closures","title":"Closures","text":"<p>Functions capture variables from their environment:</p> <pre><code>fn createCounter() -&gt; () -&gt; Int {\n    var count = 0\n\n    fn increment() -&gt; Int {\n        count += 1\n        return count\n    }\n\n    return increment\n}\n\nvar counter = createCounter()\nprint(counter())  // 1\nprint(counter())  // 2\nprint(counter())  // 3</code></pre>"},{"location":"en/guide/functions/#multiple-closures","title":"Multiple Closures","text":"<pre><code>fn createCounterWithStep(step: Int) -&gt; () -&gt; Int {\n    var count = 0\n\n    fn next() -&gt; Int {\n        count += step\n        return count\n    }\n\n    return next\n}\n\nvar byOne = createCounterWithStep(1)\nvar byFive = createCounterWithStep(5)\n\nprint(byOne())    // 1\nprint(byOne())    // 2\nprint(byFive())   // 5\nprint(byFive())   // 10</code></pre>"},{"location":"en/guide/functions/#recursion","title":"Recursion","text":"<p>Functions can call themselves:</p>"},{"location":"en/guide/functions/#factorial","title":"Factorial","text":"<pre><code>fn factorial(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return 1\n    }\n    return n * factorial(n - 1)\n}\n\nprint(factorial(5))  // 120 (5 * 4 * 3 * 2 * 1)</code></pre>"},{"location":"en/guide/functions/#fibonacci","title":"Fibonacci","text":"<pre><code>fn fibonacci(n: Int) -&gt; Int {\n    if n &lt;= 1 {\n        return n\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nprint(fibonacci(10))  // 55</code></pre>"},{"location":"en/guide/functions/#tail-recursion","title":"Tail Recursion","text":"<p>For deep recursion, use accumulators:</p> <pre><code>fn factorialTail(n: Int, acc: Int = 1) -&gt; Int {\n    if n &lt;= 1 {\n        return acc\n    }\n    return factorialTail(n - 1, n * acc)\n}\n\nprint(factorialTail(5))  // 120</code></pre>"},{"location":"en/guide/functions/#inlining","title":"Inlining","text":"<p>Hint to the native compiler to inline a function's body at call sites using the <code>@inline</code> decorator. This can improve performance for small, frequently called functions by avoiding function call overhead.</p> <pre><code>@inline\nfn add(a: Int, b: Int) -&gt; Int = a + b\n\n// This call is replaced by the actual addition instruction in the binary\nvar sum = add(5, 10)</code></pre>"},{"location":"en/guide/functions/#nested-functions","title":"Nested Functions","text":"<p>Define functions inside other functions:</p> <pre><code>fn calculateTaxes(price: Float) -&gt; Float {\n    let RATE = 0.16\n\n    fn applyRate(amount: Float) -&gt; Float {\n        return amount * RATE\n    }\n\n    var tax = applyRate(price)\n    return price + tax\n}\n\nprint(calculateTaxes(100.0))  // 116.0</code></pre>"},{"location":"en/guide/functions/#generic-functions","title":"Generic Functions","text":"<p>Functions can have type parameters. Type parameters go before the function name:</p> <pre><code>fn [T] identity(x: T) -&gt; T {\n    return x\n}\n\nprint(identity(42))      // 42\nprint(identity(\"hello\")) // hello\n\nfn [T, U] transform(value: T, f: (T) -&gt; U) -&gt; U {\n    return f(value)\n}\n\nvar doubled = transform(5, x =&gt; x * 2)\nprint(doubled)  // 10</code></pre>"},{"location":"en/guide/functions/#async-lambdas","title":"Async Lambdas","text":"<p>Async lambdas use the same <code>async</code> prefix as functions and return <code>Task[T]</code>.</p> <pre><code>var increment = async x =&gt; x + 1\nvar result = await increment(41)\nprint(result)  // 42</code></pre>"},{"location":"en/guide/functions/#common-patterns","title":"Common Patterns","text":""},{"location":"en/guide/functions/#map-transform-list","title":"Map (Transform List)","text":"<pre><code>fn [T, U] myMap(list: List[T], transform: (T) -&gt; U) -&gt; List[U] {\n    var result = []\n\n    for item in list {\n        result.push(transform(item))\n    }\n\n    return result\n}\n\nfn double(x: Int) -&gt; Int = x * 2\n\nvar numbers = [1, 2, 3, 4, 5]\nprint(myMap(numbers, double))  // [2, 4, 6, 8, 10]</code></pre>"},{"location":"en/guide/functions/#filter","title":"Filter","text":"<pre><code>fn [T] myFilter(list: List[T], predicate: (T) -&gt; Bool) -&gt; List[T] {\n    var result = []\n\n    for item in list {\n        if predicate(item) {\n            result.push(item)\n        }\n    }\n\n    return result\n}\n\nfn isEven(n: Int) -&gt; Bool = n % 2 == 0\n\nvar numbers = [1, 2, 3, 4, 5, 6]\nprint(myFilter(numbers, isEven))  // [2, 4, 6]</code></pre>"},{"location":"en/guide/functions/#reduce-accumulate","title":"Reduce (Accumulate)","text":"<pre><code>fn [T, U] myReduce(list: List[T], accumulator: (U, T) -&gt; U, initial: U) -&gt; U {\n    var result = initial\n\n    for item in list {\n        result = accumulator(result, item)\n    }\n\n    return result\n}\n\nfn add(a: Int, b: Int) -&gt; Int = a + b\n\nvar numbers = [1, 2, 3, 4, 5]\nprint(myReduce(numbers, add, 0))  // 15</code></pre>"},{"location":"en/guide/functions/#see-also","title":"See Also","text":"<ul> <li>Variables and Constants</li> <li>Advanced Features - Memoization and TCO</li> <li>Classes and Objects</li> </ul>"},{"location":"en/guide/generics/","title":"Generics","text":"<p>Language: Espa\u00f1ol | English</p> <p>Crespi supports lightweight, duck-typed generics for classes and functions using square bracket syntax.</p>"},{"location":"en/guide/generics/#generic-classes","title":"Generic Classes","text":"<p>Use square brackets to declare type parameters. Use <code>var</code> or <code>let</code> to make constructor parameters into properties:</p> <pre><code>class Box[T](var value: T) {\n    fn get() -&gt; T {\n        return this.value\n    }\n\n    fn set(newValue: T) {\n        this.value = newValue\n    }\n}\n\n// Usage - type is inferred\nvar intBox = Box(42)\nvar strBox = Box(\"hello\")\n\nprint(intBox.get())  // 42\nprint(strBox.get())  // \"hello\"</code></pre>"},{"location":"en/guide/generics/#multiple-type-parameters","title":"Multiple Type Parameters","text":"<pre><code>class Pair[A, B](let first: A, let second: B) {\n    fn swap() -&gt; Pair[B, A] {\n        return Pair(this.second, this.first)\n    }\n\n    fn getFirst() -&gt; A {\n        return this.first\n    }\n\n    fn getSecond() -&gt; B {\n        return this.second\n    }\n}\n\nvar p = Pair(1, \"one\")\nprint(p.getFirst())   // 1\nprint(p.getSecond())  // \"one\"\n\nvar swapped = p.swap()\nprint(swapped.getFirst())  // \"one\"</code></pre>"},{"location":"en/guide/generics/#generic-functions","title":"Generic Functions","text":"<p>Functions can also have type parameters. Type parameters go before the function name:</p> <pre><code>fn [T] identity(x: T) -&gt; T {\n    return x\n}\n\nprint(identity(42))      // 42\nprint(identity(\"hello\")) // \"hello\"\nprint(identity([1,2,3])) // [1, 2, 3]</code></pre>"},{"location":"en/guide/generics/#multiple-type-parameters-in-functions","title":"Multiple Type Parameters in Functions","text":"<pre><code>fn [T, U] transform(value: T, func: (T) -&gt; U) -&gt; U {\n    return func(value)\n}\n\nfn [T] double(x: Int) -&gt; Int = x * 2\nfn [T] toString(x: Int) -&gt; String = str(x)\n\nprint(transform(5, double))    // 10\nprint(transform(42, toString)) // \"42\"</code></pre>"},{"location":"en/guide/generics/#generic-constraints","title":"Generic Constraints","text":"<p>Crespi uses duck typing, so generic types aren't enforced at compile time. The code will work as long as the operations used are valid for the actual types:</p> <pre><code>class Container[T](var items: List[T] = []) {\n    fn add(item: T) {\n        this.items.push(item)\n    }\n\n    fn getAll() -&gt; List[T] {\n        return this.items\n    }\n\n    fn count() -&gt; Int {\n        return this.items.length()\n    }\n}\n\n// Works with any type\nvar numbers = Container()\nnumbers.add(1)\nnumbers.add(2)\nnumbers.add(3)\nprint(numbers.count())  // 3\n\nvar strings = Container()\nstrings.add(\"a\")\nstrings.add(\"b\")\nprint(strings.getAll())  // [\"a\", \"b\"]</code></pre>"},{"location":"en/guide/generics/#generic-methods","title":"Generic Methods","text":"<p>Classes with type parameters can have methods that use those parameters:</p> <pre><code>class Stack[T](var items: List[T] = []) {\n    fn push(item: T) {\n        this.items.push(item)\n    }\n\n    fn pop() -&gt; T? {\n        return this.items.pop()\n    }\n\n    fn peek() -&gt; T? {\n        if this.items.length() == 0 {\n            return null\n        }\n        return this.items[this.items.length() - 1]\n    }\n\n    fn isEmpty() -&gt; Bool {\n        return this.items.length() == 0\n    }\n}\n\nvar stack = Stack()\nstack.push(1)\nstack.push(2)\nstack.push(3)\n\nprint(stack.peek())  // 3\nprint(stack.pop())   // 3\nprint(stack.pop())   // 2</code></pre>"},{"location":"en/guide/generics/#nested-generics","title":"Nested Generics","text":"<p>You can use generic types within other generic types:</p> <pre><code>class Box[T](let value: T)\n\nclass DoubleBox[A, B](let boxA: Box[A], let boxB: Box[B]) {\n    fn getFirst() -&gt; A {\n        return this.boxA.value\n    }\n\n    fn getSecond() -&gt; B {\n        return this.boxB.value\n    }\n}\n\nvar a = Box(10)\nvar b = Box(\"hello\")\nvar double = DoubleBox(a, b)\n\nprint(double.getFirst())   // 10\nprint(double.getSecond())  // \"hello\"</code></pre>"},{"location":"en/guide/generics/#why-square-brackets","title":"Why Square Brackets?","text":"<p>Crespi uses <code>[T]</code> instead of <code>&lt;T&gt;</code> to avoid ambiguity with comparison operators:</p> <pre><code>// With angle brackets, this would be ambiguous:\n// var x = Foo&lt;Bar&gt;(value)  -- Is this (Foo &lt; Bar) &gt; value ?\n\n// Square brackets are unambiguous:\nvar x = Foo[Bar](value)  // Clearly a generic instantiation</code></pre>"},{"location":"en/guide/generics/#generics-behavior","title":"Generics Behavior","text":"<ul> <li>Uses square brackets <code>[T, U]</code> to avoid ambiguity with comparison operators</li> <li>Duck-typed: type parameters are parsed but not enforced at runtime</li> <li>Works with both classes and functions</li> <li>Multiple type parameters supported</li> <li>No explicit type instantiation needed (inferred from usage)</li> <li>Generics work in both the interpreter and native compilation</li> </ul>"},{"location":"en/guide/generics/#see-also","title":"See Also","text":"<ul> <li>Classes and Objects</li> <li>Functions</li> <li>Extensions</li> </ul>"},{"location":"en/guide/interpreter/","title":"Interpreter","text":"<p>Language: Espa\u00f1ol | English</p> <p>The Crespi interpreter (<code>crespi</code>) runs your code directly without compilation. It's ideal for development, learning, and scripting.</p>"},{"location":"en/guide/interpreter/#quick-start","title":"Quick Start","text":"<pre><code># Run a file\ncrespi program.crespi\n\n# Run code directly\ncrespi -c 'print(\"Hello, World!\")'\n\n# Start interactive REPL\ncrespi</code></pre>"},{"location":"en/guide/interpreter/#execution-modes","title":"Execution Modes","text":""},{"location":"en/guide/interpreter/#run-file","title":"Run File","text":"<pre><code>crespi my_program.crespi</code></pre> <p>Executes the file and displays output in the terminal.</p>"},{"location":"en/guide/interpreter/#type-check-optional","title":"Type Check (Optional)","text":"<pre><code>crespi --check my_program.crespi</code></pre> <p>Runs the static type checker before execution and exits on errors.</p>"},{"location":"en/guide/interpreter/#inline-code","title":"Inline Code","text":"<pre><code>crespi -c 'var x = 5; print(x * 2)'</code></pre> <p>Useful for quick tests without creating files.</p>"},{"location":"en/guide/interpreter/#interactive-repl","title":"Interactive REPL","text":"<pre><code>crespi\n# or explicitly:\ncrespi repl</code></pre> <p>The REPL (Read-Eval-Print Loop) lets you write and execute code line by line:</p> <pre><code>Crespi REPL v0.0.1\nType 'exit' to exit\n\n&gt;&gt;&gt; var name = \"Ana\"\n&gt;&gt;&gt; print(\"Hello, \" + name)\nHello, Ana\n&gt;&gt;&gt; exit</code></pre>"},{"location":"en/guide/interpreter/#debugging-commands","title":"Debugging Commands","text":""},{"location":"en/guide/interpreter/#view-tokens","title":"View Tokens","text":"<pre><code>crespi tokens program.crespi</code></pre> <p>Shows tokens generated by the lexer:</p> <pre><code>Token { kind: Var, lexeme: \"var\", ... }\nToken { kind: Identifier, lexeme: \"x\", ... }\nToken { kind: Equal, lexeme: \"=\", ... }\n...</code></pre>"},{"location":"en/guide/interpreter/#view-ast","title":"View AST","text":"<pre><code>crespi ast program.crespi</code></pre> <p>Shows the abstract syntax tree generated by the parser.</p>"},{"location":"en/guide/interpreter/#cli-reference","title":"CLI Reference","text":"Command Description <code>crespi &lt;file&gt;</code> Run a file <code>crespi -c &lt;code&gt;</code> Run inline code <code>crespi repl</code> Start interactive REPL <code>crespi tokens &lt;file&gt;</code> Show lexer tokens <code>crespi ast &lt;file&gt;</code> Show syntax tree <code>crespi --check &lt;file&gt;</code> Run type checker before execution <code>crespi --help</code> Show help <code>crespi --version</code> Show version"},{"location":"en/guide/interpreter/#supported-features","title":"Supported Features","text":"<p>The interpreter supports all language features:</p> <ul> <li>Variables and constants</li> <li>All data types (including dictionaries)</li> <li>Control flow: <code>if</code>, <code>while</code>, <code>for</code></li> <li>Functions and closures</li> <li>Classes with inheritance</li> <li>Decorators (<code>@memoize</code>)</li> <li>Tail-call optimization (TCO)</li> </ul>"},{"location":"en/guide/interpreter/#when-to-use-the-interpreter","title":"When to Use the Interpreter","text":"Use Case Recommendation Development and testing \u2705 Interpreter Learning the language \u2705 Interpreter Quick scripts \u2705 Interpreter Using dictionaries \u2705 Interpreter (only option) Distributing executables \u274c Use compiler Maximum performance \u274c Use compiler"},{"location":"en/guide/interpreter/#see-also","title":"See Also","text":"<ul> <li>Native Compiler - Compile to executables</li> <li>Variables - Data types and variables</li> <li>Functions - Defining and using functions</li> </ul>"},{"location":"en/guide/variables/","title":"Variables and Constants","text":"<p>Language: Espa\u00f1ol | English</p> <p>In Crespi, you can store values using mutable variables or immutable constants.</p>"},{"location":"en/guide/variables/#variables","title":"Variables","text":"<p>Use <code>var</code> to declare values that can change:</p> <pre><code>var name = \"Ana\"\nvar age = 25\nvar active = true\n\nprint(name)  // Ana\nprint(age)   // 25</code></pre>"},{"location":"en/guide/variables/#reassignment","title":"Reassignment","text":"<p>Variables can change their value at any time:</p> <pre><code>var counter = 0\nprint(counter)    // 0\n\ncounter = 1\nprint(counter)    // 1\n\ncounter = counter + 1\nprint(counter)    // 2</code></pre>"},{"location":"en/guide/variables/#type-inference","title":"Type Inference","text":"<p>When the optional static type checker runs, Crespi uses type inference to determine variable types from their initial values:</p> <pre><code>var x = 42        // inferred as Int\nvar y = \"hello\"   // inferred as String\nvar z = [1, 2, 3] // inferred as List[Int]\n\n// You can also add explicit type annotations\nvar count: Int = 0\nvar name: String = \"Alice\"</code></pre> <p>With the checker enabled, a variable's inferred or annotated type must remain consistent. Without it, reassignment can use any type at runtime.</p>"},{"location":"en/guide/variables/#constants","title":"Constants","text":"<p>Use <code>let</code> for values that should not change:</p> <pre><code>let PI = 3.14159\nlet MAX_ATTEMPTS = 3\nlet APP_NAME = \"My Application\"\n\nprint(PI)  // 3.14159</code></pre> <p>Note: <code>PI</code> and <code>E</code> are built-in constants. In native-compiled code they are lowered to <code>pi()</code> and <code>e()</code> built-ins.</p>"},{"location":"en/guide/variables/#immutability","title":"Immutability","text":"<p>Attempting to reassign a constant produces an error:</p> <pre><code>let LIMIT = 100\n\n// LIMIT = 200  // Error: cannot reassign a let constant</code></pre> <p><code>let</code> also freezes collections. Lists and dictionaries bound to <code>let</code> cannot be mutated (no index assignment, <code>push</code>, or <code>pop</code>), and tuples are always immutable:</p> <pre><code>let ids = [1, 2, 3]\n// ids[0] = 9     // Error: cannot modify a let list\n// ids.push(4)   // Error: cannot modify a let list\n\nlet profile = { \"name\": \"Ana\" }\n// profile[\"name\"] = \"Bea\"  // Error: cannot modify a let dictionary</code></pre>"},{"location":"en/guide/variables/#when-to-use-constants","title":"When to Use Constants","text":"<p>Use constants for: - Mathematical values (PI, E) - Fixed configurations - Threshold or limit values - Any value that should not change</p> <pre><code>let GRAVITY = 9.81\nlet TAX_RATE = 0.21\nlet DAYS_PER_WEEK = 7\n\nfn calculate_weight(mass) {\n    return mass * GRAVITY\n}\n\nfn calculate_price_with_tax(price) {\n    return price * (1 + TAX_RATE)\n}</code></pre>"},{"location":"en/guide/variables/#assignment-operators","title":"Assignment Operators","text":""},{"location":"en/guide/variables/#simple-assignment","title":"Simple Assignment","text":"<pre><code>var x = 10</code></pre>"},{"location":"en/guide/variables/#compound-assignment","title":"Compound Assignment","text":"<p>Crespi supports compound assignment operators:</p> Operator Equivalent Description <code>+=</code> <code>x = x + value</code> Add and assign <code>-=</code> <code>x = x - value</code> Subtract and assign <code>*=</code> <code>x = x * value</code> Multiply and assign <code>/=</code> <code>x = x / value</code> Divide and assign <pre><code>var points = 100\n\npoints += 50    // points = 150\nprint(points)   // 150\n\npoints -= 30    // points = 120\nprint(points)   // 120\n\npoints *= 2     // points = 240\nprint(points)   // 240\n\npoints /= 4     // points = 60\nprint(points)   // 60</code></pre>"},{"location":"en/guide/variables/#use-in-loops","title":"Use in Loops","text":"<p>Compound operators are useful in loops:</p> <pre><code>var sum = 0\nvar numbers = [1, 2, 3, 4, 5]\n\nfor n in numbers {\n    sum += n\n}\n\nprint(sum)  // 15</code></pre>"},{"location":"en/guide/variables/#variable-scope","title":"Variable Scope","text":"<p>Variables have lexical scope. A variable declared inside a block only exists in that block:</p> <pre><code>var global = \"I am global\"\n\nif true {\n    var local = \"I am local\"\n    print(local)   // OK: I am local\n    print(global)  // OK: I am global\n}\n\nprint(global)  // OK: I am global\n// print(local)  // Error: undefined variable</code></pre>"},{"location":"en/guide/variables/#shadowing","title":"Shadowing","text":"<p>An inner variable can \"shadow\" an outer one with the same name:</p> <pre><code>var x = 10\n\nif true {\n    var x = 20  // New variable, shadows outer\n    print(x)    // 20\n}\n\nprint(x)  // 10 (original unchanged)</code></pre>"},{"location":"en/guide/variables/#closures","title":"Closures","text":"<p>Functions capture variables from their environment:</p> <pre><code>var factor = 2\n\nfn multiply(x) {\n    return x * factor  // Uses 'factor' from outer scope\n}\n\nprint(multiply(5))  // 10\n\nfactor = 3\nprint(multiply(5))  // 15 (uses new value)</code></pre>"},{"location":"en/guide/variables/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Use <code>camelCase</code> for both variables and constants so naming stays consistent.</li> <li>Choose descriptive names that indicate an identifier's purpose.</li> </ul> <pre><code>var userName = \"ana123\"\nlet maxAttempts = 3\nlet connectionTimeout = 30</code></pre>"},{"location":"en/guide/variables/#initialization","title":"Initialization","text":""},{"location":"en/guide/variables/#with-literal-value","title":"With Literal Value","text":"<pre><code>var integer = 42\nvar decimal = 3.14\nvar text = \"Hello\"\nvar boolean = true\nvar list = [1, 2, 3]\nvar dictionary = {\"key\": \"value\"}</code></pre>"},{"location":"en/guide/variables/#with-expression","title":"With Expression","text":"<pre><code>var sum = 10 + 20\nvar len = \"Hello World\".length()\nvar doubled = [1, 2, 3][0] * 2</code></pre>"},{"location":"en/guide/variables/#with-function-result","title":"With Function Result","text":"<pre><code>fn calculate() {\n    return 42\n}\n\nvar result = calculate()\nprint(result)  // 42</code></pre>"},{"location":"en/guide/variables/#with-null-value","title":"With Null Value","text":"<pre><code>var pending = null\n\n// Later...\npending = fetch_data()</code></pre>"},{"location":"en/guide/variables/#practical-examples","title":"Practical Examples","text":""},{"location":"en/guide/variables/#counter","title":"Counter","text":"<pre><code>var counter = 0\n\nfn increment() {\n    counter += 1\n}\n\nfn get() {\n    return counter\n}\n\nincrement()\nincrement()\nincrement()\nprint(get())  // 3</code></pre>"},{"location":"en/guide/variables/#accumulator","title":"Accumulator","text":"<pre><code>var total = 0\nvar prices = [10.50, 25.00, 8.75, 12.25]\n\nfor price in prices {\n    total += price\n}\n\nprint(\"Total: \" + str(total))  // Total: 56.5</code></pre>"},{"location":"en/guide/variables/#value-swap","title":"Value Swap","text":"<pre><code>var a = 10\nvar b = 20\n\n// Swap using temporary variable\nvar temp = a\na = b\nb = temp\n\nprint(a)  // 20\nprint(b)  // 10</code></pre>"},{"location":"en/guide/variables/#visibility","title":"Visibility","text":"<p>Top-level declarations (variables, constants, functions, and classes) can use visibility modifiers to control how they are accessed from other modules:</p> <ul> <li><code>public</code> (default): Accessible from any other module.</li> <li><code>internal</code>: Accessible only from modules in the same directory.</li> <li><code>fileprivate</code>: Accessible only from within the same file.</li> <li><code>private</code>: Same as <code>fileprivate</code> (for backward compatibility).</li> </ul> <pre><code>public var siteName = \"Crespi\"\ninternal var localCount = 0\nfileprivate fn helper() { ... }</code></pre>"},{"location":"en/guide/variables/#see-also","title":"See Also","text":"<ul> <li>Control Flow</li> <li>Functions</li> <li>Keywords</li> </ul>"},{"location":"en/reference/ffi/","title":"FFI (Foreign Function Interface)","text":"<p>Language: Espanol | English</p> <p>Crespi provides a Foreign Function Interface (FFI) for seamless integration with native libraries. Currently, Rust is the primary supported language, with the architecture designed to support additional languages in the future.</p> <p>The Rust FFI integration allows you to leverage the entire Rust ecosystem from your Crespi programs. This is achieved through the <code>crespigen</code> tool, which automatically generates FFI bindings for any Rust crate.</p>"},{"location":"en/reference/ffi/#overview","title":"Overview","text":"<p>The FFI system works by:</p> <ol> <li>Analyzing the public API of a Rust crate using rustdoc JSON</li> <li>Generating wrapper functions that bridge between Crespi's value system and native Rust types</li> <li>Producing a Crespi facade file (<code>.crespi</code>) with class and function definitions</li> <li>Compiling everything into a static library that links with your Crespi program</li> </ol>"},{"location":"en/reference/ffi/#quick-start","title":"Quick Start","text":""},{"location":"en/reference/ffi/#1-create-a-project-structure","title":"1. Create a Project Structure","text":"<pre><code>my_project/\n\u251c\u2500\u2500 main.crespi          # Your Crespi program\n\u251c\u2500\u2500 Cargo.toml           # Rust dependencies\n\u2514\u2500\u2500 src/\n    \u2514\u2500\u2500 lib.rs           # (Optional) Your Rust library code</code></pre>"},{"location":"en/reference/ffi/#2-configure-cargotoml","title":"2. Configure Cargo.toml","text":"<p>For using existing crates from crates.io:</p> <pre><code>[package]\nname = \"my_project\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"rlib\"]\n\n[workspace]\n\n[dependencies]\n# Add any Rust crate\nregex = \"1.10\"</code></pre> <p>For a local library:</p> <pre><code>[package]\nname = \"my_math_lib\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"rlib\"]\n\n[workspace]</code></pre> <p>Note: The empty <code>[workspace]</code> section is required to prevent Cargo workspace inheritance issues.</p>"},{"location":"en/reference/ffi/#3-write-rust-code-optional","title":"3. Write Rust Code (Optional)","text":"<p>If you're creating your own library:</p> <pre><code>// src/lib.rs\n\n/// A 2D point\n#[derive(Clone)]\npub struct Point {\n    pub x: f64,\n    pub y: f64,\n}\n\nimpl Point {\n    pub fn new(x: f64, y: f64) -&gt; Self {\n        Point { x, y }\n    }\n\n    pub fn distance(&amp;self, other: &amp;Point) -&gt; f64 {\n        ((other.x - self.x).powi(2) + (other.y - self.y).powi(2)).sqrt()\n    }\n}\n\npub fn add(a: i64, b: i64) -&gt; i64 {\n    a + b\n}\n\npub fn midpoint(p1: &amp;Point, p2: &amp;Point) -&gt; Point {\n    Point {\n        x: (p1.x + p2.x) / 2.0,\n        y: (p1.y + p2.y) / 2.0,\n    }\n}</code></pre>"},{"location":"en/reference/ffi/#4-generate-bindings","title":"4. Generate Bindings","text":"<pre><code>crespigen my_project/</code></pre> <p>This generates: - <code>my_project/target/crespi-gen/bindings.crespi</code> - Crespi facade file - <code>my_project/target/crespi-gen/target/release/lib_crespi_bindings.a</code> - Static library</p>"},{"location":"en/reference/ffi/#5-use-in-crespi","title":"5. Use in Crespi","text":"<pre><code>// main.crespi\n\nfn main() {\n    // Primitive functions work directly\n    var sum = add(10, 20)\n    print(sum)  // 30\n\n    // Structs become classes\n    var p1 = Point(0.0, 0.0)\n    var p2 = Point(3.0, 4.0)\n\n    // Methods work naturally\n    var dist = p1.distance(p2)\n    print(dist)  // 5.0\n\n    // Free functions with struct parameters\n    var mid = midpoint(p1, p2)\n    print(mid.x())  // 1.5\n    print(mid.y())  // 2.0\n}</code></pre>"},{"location":"en/reference/ffi/#type-mapping","title":"Type Mapping","text":""},{"location":"en/reference/ffi/#primitive-types-direct-ffi","title":"Primitive Types (Direct FFI)","text":"<p>Primitive types are passed directly without conversion overhead.</p> Rust Type Crespi Type Notes <code>i64</code>, <code>isize</code> <code>Int</code> 64-bit signed integer <code>i32</code> <code>Int32</code> 32-bit signed integer <code>i16</code> <code>Int16</code> 16-bit signed integer <code>i8</code> <code>Int8</code> 8-bit signed integer <code>u64</code>, <code>usize</code> <code>UInt</code> 64-bit unsigned integer <code>u32</code> <code>UInt32</code> 32-bit unsigned integer <code>u16</code> <code>UInt16</code> 16-bit unsigned integer <code>u8</code> <code>UInt8</code> 8-bit unsigned integer <code>f64</code> <code>Double</code> 64-bit floating point <code>f32</code> <code>Float</code> 32-bit floating point <code>bool</code> <code>Bool</code> Direct mapping <code>()</code> <code>Unit</code> Void/unit type"},{"location":"en/reference/ffi/#complex-types-wrapper-generation","title":"Complex Types (Wrapper Generation)","text":"<p>Complex types require wrapper functions for marshaling.</p> Rust Type Crespi Type Notes <code>String</code>, <code>&amp;str</code> <code>String</code> Automatic conversion <code>Vec&lt;T&gt;</code> <code>List[T]</code> List with element type <code>HashMap&lt;K, V&gt;</code> <code>Dict[K, V]</code> Dictionary mapping <code>Option&lt;T&gt;</code> <code>T?</code> Nullable type <code>Result&lt;T, E&gt;</code> <code>T?</code> Errors become null Custom <code>struct</code> <code>class</code> Auto-generated class Custom <code>enum</code> <code>class</code> Variant constructors <p>If a Rust type cannot be mapped, crespi-cargo falls back to <code>Any</code> so the item remains available.</p>"},{"location":"en/reference/ffi/#smart-pointers","title":"Smart Pointers","text":"<p>Smart pointers are automatically unwrapped to their inner type.</p> Rust Type Crespi Type <code>Box&lt;T&gt;</code> <code>T</code> <code>Rc&lt;T&gt;</code> <code>T</code> <code>Arc&lt;T&gt;</code> <code>T</code> <code>Cow&lt;T&gt;</code> <code>T</code>"},{"location":"en/reference/ffi/#generated-bindings","title":"Generated Bindings","text":""},{"location":"en/reference/ffi/#struct-mapping","title":"Struct Mapping","text":"<p>Rust structs become Crespi classes with:</p> <ul> <li>Constructor: Uses field names as parameters</li> <li>Field getters: Methods returning field values</li> <li>Methods: Instance methods from <code>impl</code> blocks</li> <li>Tuple structs: Positional fields are exposed as <code>field0</code>, <code>field1</code>, ...</li> </ul> <p>Rust: <pre><code>pub struct Person {\n    pub name: String,\n    pub age: i32,\n}\n\nimpl Person {\n    pub fn new(name: String, age: i32) -&gt; Self {\n        Person { name, age }\n    }\n\n    pub fn greet(&amp;self) -&gt; String {\n        format!(\"Hello, I'm {} and I'm {} years old\", self.name, self.age)\n    }\n}</code></pre></p> <p>Generated Crespi: <pre><code>class Person {\n    private var _ptr: Any\n\n    fn init(name: String, age: Int) {\n        this._ptr = __crespi_Person_new(name, age)\n    }\n\n    fn name() -&gt; String {\n        return __crespi_Person_get_name(this._ptr)\n    }\n\n    fn age() -&gt; Int {\n        return __crespi_Person_get_age(this._ptr)\n    }\n\n    fn greet() -&gt; String {\n        return __crespi_Person_greet(this._ptr)\n    }\n}</code></pre></p>"},{"location":"en/reference/ffi/#free-functions","title":"Free Functions","text":"<p>Free functions are wrapped with the same name:</p> <p>Rust: <pre><code>pub fn calculate_area(width: f64, height: f64) -&gt; f64 {\n    width * height\n}</code></pre></p> <p>Generated Crespi: <pre><code>extern fn __crespi_calculate_area(width: Double, height: Double) -&gt; Double\n\nfn calculate_area(width: Double, height: Double) -&gt; Double {\n    return __crespi_calculate_area(width, height)\n}</code></pre></p>"},{"location":"en/reference/ffi/#enum-mapping","title":"Enum Mapping","text":"<p>Rust enums become classes with static constructors for each variant. Tuple variants use positional parameters like <code>field0</code>, <code>field1</code>, and so on.</p> <p>Rust: <pre><code>pub enum Color {\n    Red,\n    Green,\n    Blue,\n    Rgb(u8, u8, u8),\n}</code></pre></p> <p>Generated Crespi: <pre><code>class Color {\n    private var _tag: Int\n    private var _data: Any\n\n    fn Red() -&gt; Color { ... }\n    fn Green() -&gt; Color { ... }\n    fn Blue() -&gt; Color { ... }\n    fn Rgb(r: Int, g: Int, b: Int) -&gt; Color { ... }\n\n    fn is_red() -&gt; Bool { return this._tag == 0 }\n    fn is_green() -&gt; Bool { return this._tag == 1 }\n    fn is_blue() -&gt; Bool { return this._tag == 2 }\n    fn is_rgb() -&gt; Bool { return this._tag == 3 }\n}</code></pre></p>"},{"location":"en/reference/ffi/#crespigen-command","title":"crespigen Command","text":""},{"location":"en/reference/ffi/#usage","title":"Usage","text":"<pre><code>crespigen [OPTIONS] &lt;PROJECT_DIR&gt;</code></pre>"},{"location":"en/reference/ffi/#arguments","title":"Arguments","text":"Argument Description <code>&lt;PROJECT_DIR&gt;</code> Path to the Rust project (directory containing Cargo.toml)"},{"location":"en/reference/ffi/#options","title":"Options","text":"Option Description <code>-o, --output &lt;DIR&gt;</code> Output directory for generated bindings (default: <code>&lt;project&gt;/target/crespi-gen</code>) <code>--no-build</code> Only generate bindings, don't compile <code>-h, --help</code> Print help <code>-V, --version</code> Print version"},{"location":"en/reference/ffi/#output-files","title":"Output Files","text":"<p>After running <code>crespigen</code>, you'll find:</p> <pre><code>my_project/\n\u2514\u2500\u2500 target/\n    \u2514\u2500\u2500 crespi-gen/\n        \u251c\u2500\u2500 Cargo.toml           # Wrapper crate manifest\n        \u251c\u2500\u2500 src/\n        \u2502   \u2514\u2500\u2500 lib.rs           # Generated Rust wrappers\n        \u251c\u2500\u2500 bindings.crespi      # Crespi facade file\n        \u2514\u2500\u2500 target/\n            \u2514\u2500\u2500 release/\n                \u2514\u2500\u2500 lib_crespi_bindings.a  # Static library</code></pre>"},{"location":"en/reference/ffi/#requirements","title":"Requirements","text":""},{"location":"en/reference/ffi/#rust-nightly","title":"Rust Nightly","text":"<p>The <code>crespigen</code> tool requires Rust nightly for rustdoc JSON output:</p> <pre><code># Install nightly\nrustup install nightly\n\n# Make nightly available\nrustup default nightly\n# OR use +nightly flag\ncargo +nightly ...</code></pre>"},{"location":"en/reference/ffi/#path-configuration","title":"PATH Configuration","text":"<p>Ensure <code>cargo</code> is available in your PATH. Add to your shell configuration:</p> <pre><code># ~/.zshrc or ~/.bashrc\nexport PATH=\"$HOME/.cargo/bin:$PATH\"</code></pre>"},{"location":"en/reference/ffi/#how-it-works","title":"How It Works","text":""},{"location":"en/reference/ffi/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Rust Crate    \u2502\u2500\u2500\u2500\u2500&gt;\u2502  crespigen   \u2502\u2500\u2500\u2500\u2500&gt;\u2502  bindings.crespi\u2502\n\u2502   (Cargo.toml)  \u2502     \u2502              \u2502     \u2502  lib_crespi_*.a \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502                   \u2502\n               \u250c\u2500\u2500\u2500\u2500v\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500v\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n               \u2502 rustdoc \u2502       \u2502 Embedded    \u2502\n               \u2502  JSON   \u2502       \u2502 crespi-ffi  \u2502\n               \u2502         \u2502       \u2502 crespi-runtime\n               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518</code></pre>"},{"location":"en/reference/ffi/#process-flow","title":"Process Flow","text":"<ol> <li>Rustdoc JSON Generation: <code>crespigen</code> runs <code>cargo +nightly doc</code> with JSON output to extract the public API</li> <li>API Parsing: The rustdoc JSON is parsed to discover functions, structs, enums, and methods</li> <li>Type Mapping: Rust types are mapped to Crespi types</li> <li>Wrapper Generation: Rust wrapper functions are generated that:</li> <li>Accept <code>CrespiValue</code> arguments</li> <li>Marshal values to native Rust types</li> <li>Call the original functions</li> <li>Convert results back to <code>CrespiValue</code></li> <li>Facade Generation: A <code>.crespi</code> file is generated with:</li> <li><code>extern fn</code> declarations for the FFI functions</li> <li>Class definitions for structs</li> <li>Wrapper functions for ergonomic API</li> <li>Compilation: The wrapper crate is compiled to a static library</li> </ol>"},{"location":"en/reference/ffi/#opaque-pointers","title":"Opaque Pointers","text":"<p>Custom structs are handled as opaque pointers:</p> <ul> <li>Struct instances are boxed and stored as raw pointers in <code>CrespiValue</code></li> <li>Methods receive the pointer, dereference it, and call the method</li> <li>Return values that are structs are boxed and returned as opaque pointers</li> </ul> <p>This approach: - Avoids copying large structs - Preserves Rust ownership semantics - Allows calling methods on instances</p>"},{"location":"en/reference/ffi/#limitations","title":"Limitations","text":""},{"location":"en/reference/ffi/#current-limitations","title":"Current Limitations","text":""},{"location":"en/reference/ffi/#fully-supported","title":"Fully Supported","text":"<ul> <li>Primitive numeric types (signed/unsigned ints, <code>f32</code>/<code>f64</code>, <code>bool</code>) in functions and struct fields</li> <li>Structs with primitive fields only</li> <li>Methods with <code>&amp;self</code> receiver</li> <li>Methods taking <code>&amp;StructType</code> references as parameters</li> <li>Methods returning <code>Self</code> or other struct types</li> <li>Free functions with primitive parameters</li> <li>Free functions with <code>&amp;StructType</code> parameters</li> </ul>"},{"location":"en/reference/ffi/#not-yet-supported-planned","title":"Not Yet Supported (Planned)","text":"Feature Issue Workaround Static factory methods Methods without <code>&amp;self</code> (e.g., <code>Point::origin()</code>) are incorrectly generated as instance methods Use constructors with default values: <code>Point(0.0, 0.0)</code> instead of <code>Point::origin()</code> Struct fields containing other structs Fields like <code>center: Point</code> in a <code>Circle</code> struct fail to marshal Use primitive fields: <code>cx: f64, cy: f64</code> instead of <code>center: Point</code> Methods taking owned struct parameters <code>fn move_to(self, center: Point)</code> expects owned value, not reference Use references: <code>fn move_to(&amp;self, center: &amp;Point)</code> Enum marshalling Enum values are still treated as opaque pointers in FFI calls Use wrapper functions that return primitives/structs where possible Generics Generic functions and structs have limited support Use concrete types in public APIs Traits Trait objects (<code>dyn Trait</code>) are treated as opaque <code>Any</code> Avoid trait objects in FFI boundaries Lifetimes References with explicit lifetimes may not work correctly Use owned types or <code>&amp;T</code> without explicit lifetimes Async Crespi supports <code>async</code>/<code>await</code>, but Rust <code>async fn</code> (Future) interop is not supported Expose sync wrappers or use blocking APIs Callbacks Passing Crespi functions to Rust is not supported Design APIs without callbacks String/Vec returns Complex return types need marshaling Currently limited - use primitives when possible"},{"location":"en/reference/ffi/#design-recommendations","title":"Design Recommendations","text":"<ol> <li>Use concrete types in public APIs when possible</li> <li>Prefer <code>&amp;self</code> methods over consuming <code>self</code> methods</li> <li>Return <code>Result</code> or <code>Option</code> for fallible operations</li> <li>Derive <code>Clone</code> for structs that need to be copied</li> <li>Keep public APIs simple - internal complexity is fine</li> </ol>"},{"location":"en/reference/ffi/#tokio-helper-crate","title":"Tokio helper crate","text":"<p><code>crespi-tokio</code> provides a small, blocking wrapper over Tokio for Crespi-friendly use. It exposes <code>sleep_ms</code>, <code>join_sleep_ms</code>, <code>race_sleep_ms</code>, and a <code>Runtime</code> wrapper that can be used via <code>crespi-cargo</code>.</p> <pre><code>extern fn sleep_ms(ms: Int)\nextern fn join_sleep_ms(a: Int, b: Int) -&gt; Int\n\nsleep_ms(50)\nprint(join_sleep_ms(10, 30))</code></pre>"},{"location":"en/reference/ffi/#examples","title":"Examples","text":""},{"location":"en/reference/ffi/#using-a-cratesio-library","title":"Using a crates.io Library","text":"<pre><code># Cargo.toml\n[package]\nname = \"regex_example\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\ncrate-type = [\"rlib\"]\n\n[workspace]\n\n[dependencies]\nregex = \"1.10\"</code></pre> <pre><code>// main.crespi\nfn main() {\n    var pattern = Regex(\"[0-9]+\")\n\n    if pattern.is_match(\"abc123\") {\n        print(\"Found digits!\")\n    }\n\n    var matches = pattern.find_all(\"a1b2c3\")\n    for m in matches {\n        print(m)  // \"1\", \"2\", \"3\"\n    }\n}</code></pre>"},{"location":"en/reference/ffi/#local-math-library","title":"Local Math Library","text":"<pre><code>// src/lib.rs\npub fn factorial(n: i64) -&gt; i64 {\n    if n &lt;= 1 { 1 } else { n * factorial(n - 1) }\n}\n\npub fn fibonacci(n: i64) -&gt; i64 {\n    if n &lt;= 1 { n } else { fibonacci(n - 1) + fibonacci(n - 2) }\n}\n\npub struct Complex {\n    pub real: f64,\n    pub imag: f64,\n}\n\nimpl Complex {\n    pub fn new(real: f64, imag: f64) -&gt; Self {\n        Complex { real, imag }\n    }\n\n    pub fn magnitude(&amp;self) -&gt; f64 {\n        (self.real * self.real + self.imag * self.imag).sqrt()\n    }\n\n    pub fn add(&amp;self, other: &amp;Complex) -&gt; Complex {\n        Complex {\n            real: self.real + other.real,\n            imag: self.imag + other.imag,\n        }\n    }\n}</code></pre> <pre><code>// main.crespi\nfn main() {\n    // Using free functions\n    print(factorial(10))    // 3628800\n    print(fibonacci(10))    // 55\n\n    // Using Complex class\n    var c1 = Complex(3.0, 4.0)\n    var c2 = Complex(1.0, 2.0)\n\n    print(c1.magnitude())   // 5.0\n\n    var sum = c1.add(c2)\n    print(sum.real())       // 4.0\n    print(sum.imag())       // 6.0\n}</code></pre>"},{"location":"en/reference/ffi/#troubleshooting","title":"Troubleshooting","text":""},{"location":"en/reference/ffi/#nightly-rust-required","title":"\"Nightly Rust Required\"","text":"<pre><code>Error: cargo +nightly failed</code></pre> <p>Solution: Install and configure Rust nightly: <pre><code>rustup install nightly\nrustup default nightly</code></pre></p>"},{"location":"en/reference/ffi/#package-believes-its-in-a-workspace","title":"\"Package believes it's in a workspace\"","text":"<pre><code>Error: current package believes it's in a workspace when it's not</code></pre> <p>Solution: Add an empty <code>[workspace]</code> section to your Cargo.toml: <pre><code>[workspace]</code></pre></p>"},{"location":"en/reference/ffi/#type-x-does-not-implement-fromcrespi","title":"\"Type X does not implement FromCrespi\"","text":"<p>This occurs when the generator tries to use a type that can't be automatically marshaled.</p> <p>Solution: Ensure your structs use supported field types, or file an issue for the unsupported type.</p>"},{"location":"en/reference/ffi/#missing-functions-in-generated-bindings","title":"Missing Functions in Generated Bindings","text":"<p>Only <code>pub</code> functions and items are included in the generated bindings.</p> <p>Solution: Mark items as <code>pub</code> that you want to expose to Crespi.</p>"},{"location":"en/reference/ffi/#future-work","title":"Future Work","text":"<p>The FFI system is designed with multi-language interoperability in mind. While Rust is currently the primary supported language, the architecture allows for future expansion to support additional languages through the same marshaling layer.</p>"},{"location":"en/reference/ffi/#see-also","title":"See Also","text":"<ul> <li>Types Reference - Crespi type system</li> <li>Functions Reference - Built-in functions</li> <li>Keywords Reference - Language keywords including <code>extern</code></li> </ul>"},{"location":"en/reference/functions/","title":"Built-in Functions","text":"<p>Language: Espa\u00f1ol | English</p> <p>Crespi includes built-in functions available globally. English names are canonical; language packs provide localized aliases that are normalized during lexing.</p> <p>Collection and string helpers are exposed as methods on their receivers (for example <code>list.length()</code>, <code>text.trim()</code>, <code>dict.keys()</code>), not as global functions.</p>"},{"location":"en/reference/functions/#reference-table","title":"Reference Table","text":""},{"location":"en/reference/functions/#core-functions-global","title":"Core Functions (Global)","text":"Function Spanish Alias Parameters Returns Description <code>print</code> <code>mostrar</code> value <code>null</code> Prints a value to output <code>read</code> <code>leer</code> - <code>string</code> Reads a line from input <code>typeof</code> <code>tipo_de</code> value <code>string</code> Gets the type name <code>str</code> <code>texto</code> value <code>string</code> Converts to string <code>int</code> <code>entero</code> value <code>int</code> Converts to integer <code>float</code> <code>decimal</code> value <code>float</code> Converts to float <code>memoize</code> <code>memorizar</code> function <code>function</code> Creates memoized function <code>inline</code> <code>inline</code> function <code>function</code> Hints compiler to inline (no-op in interpreter)"},{"location":"en/reference/functions/#primitive-methods-collections-and-strings","title":"Primitive Methods (Collections and Strings)","text":"Method Spanish Alias Receiver Parameters Returns Description <code>length</code> / <code>len</code> <code>longitud</code> string/list/tuple/dict - <code>int</code> Gets the length <code>push</code> <code>agregar</code> list value <code>null</code> Appends to end of list <code>pop</code> <code>quitar</code> list - value Removes and returns last <code>keys</code> <code>claves</code> dict - <code>list</code> Gets the keys <code>values</code> <code>valores</code> dict - <code>list</code> Gets the values <code>contains</code> <code>contiene</code> string/list/dict value <code>bool</code> Checks if contains"},{"location":"en/reference/functions/#math-functions","title":"Math Functions","text":"Function Spanish Alias Parameters Returns Description <code>abs</code> <code>absoluto</code> number <code>number</code> Absolute value <code>sign</code> <code>signo</code> number <code>int</code> Sign of a number (-1, 0, 1) <code>sqrt</code> <code>raiz</code> number <code>float</code> Square root <code>cbrt</code> <code>raiz_cubica</code> number <code>float</code> Cube root <code>pow</code> <code>potencia</code> base, exp <code>float</code> Power <code>round</code> <code>redondear</code> number <code>int</code> Round to nearest integer <code>floor</code> <code>piso</code> number <code>int</code> Round down <code>ceil</code> <code>techo</code> number <code>int</code> Round up <code>truncate</code> <code>truncar</code> number <code>int</code> Round toward zero <code>min</code> <code>minimo</code> list or number, number <code>number</code> Minimum value <code>max</code> <code>maximo</code> list or number, number <code>number</code> Maximum value <code>random</code> <code>aleatorio</code> - <code>float</code> Random number (0.0\u20131.0) <code>random_seed</code> <code>semilla_aleatoria</code> seed <code>null</code> Seed the RNG for deterministic random <code>sin</code> <code>seno</code> number <code>float</code> Sine (radians) <code>cos</code> <code>coseno</code> number <code>float</code> Cosine (radians) <code>tan</code> <code>tangente</code> number <code>float</code> Tangent (radians) <code>asin</code> <code>aseno</code> number <code>float</code> Arcsine <code>acos</code> <code>acoseno</code> number <code>float</code> Arccosine <code>atan</code> <code>atangente</code> number <code>float</code> Arctangent <code>atan2</code> <code>atangente2</code> y, x <code>float</code> Two-argument arctangent <code>exp</code> <code>exponencial</code> number <code>float</code> e^x <code>ln</code> <code>logaritmo_natural</code> number <code>float</code> Natural log <code>log10</code> <code>logaritmo10</code> number <code>float</code> Base-10 log <code>log2</code> <code>logaritmo2</code> number <code>float</code> Base-2 log <code>hypot</code> <code>hipotenusa</code> x, y <code>float</code> sqrt(x^2 + y^2) <code>pi</code> <code>pi</code> - <code>float</code> \u03c0 constant (call as <code>pi()</code>) <code>e</code> <code>e</code> - <code>float</code> Euler's number (call as <code>e()</code>)"},{"location":"en/reference/functions/#string-methods","title":"String Methods","text":"Function Spanish Alias Parameters Returns Description <code>split</code> <code>dividir</code> delimiter <code>list</code> Split string by delimiter <code>trim</code> <code>recortar</code> - <code>string</code> Trim whitespace <code>uppercase</code> <code>mayusculas</code> - <code>string</code> Uppercase string <code>lowercase</code> <code>minusculas</code> - <code>string</code> Lowercase string <code>substring</code> <code>subcadena</code> start, end? <code>string</code> Slice by character index <code>replace</code> <code>reemplazar</code> old, new <code>string</code> Replace all occurrences <code>starts_with</code> <code>empieza_con</code> prefix <code>bool</code> Prefix check <code>ends_with</code> <code>termina_con</code> suffix <code>bool</code> Suffix check <code>index_of</code> <code>indice_de</code> substring <code>int</code> Character index or -1 <code>join</code> <code>unir</code> separator <code>string</code> Join list into string (on lists)"},{"location":"en/reference/functions/#collection-methods","title":"Collection Methods","text":"Function Spanish Alias Parameters Returns Description <code>map</code> <code>mapear</code> fn <code>list</code> Map items <code>filter</code> <code>filtrar</code> fn <code>list</code> Filter items <code>reduce</code> <code>reducir</code> fn, initial? value Reduce to a single value <code>sort</code> <code>ordenar</code> comparator? <code>list</code> Sort list <code>reverse</code> <code>invertir</code> - <code>list</code> Reverse list <code>slice</code> <code>cortar</code> start, end? <code>list</code> Slice list <code>find</code> <code>encontrar</code> fn value First match or null <code>every</code> <code>cada</code> fn <code>bool</code> All match predicate <code>some</code> <code>alguno</code> fn <code>bool</code> Any match predicate <code>flatten</code> <code>aplanar</code> - <code>list</code> Flatten one level"},{"location":"en/reference/functions/#inputoutput","title":"Input/Output","text":""},{"location":"en/reference/functions/#printvalue","title":"<code>print(value)</code>","text":"<p>Prints a value to standard output.</p> <p>Parameters: - <code>value</code> - Any value to display</p> <p>Returns: <code>null</code></p> <pre><code>print(\"Hello, World!\")     // Hello, World!\nprint(42)                   // 42\nprint(3.14)                 // 3.14\nprint(true)                 // true\nprint([1, 2, 3])            // [1, 2, 3]\nprint({\"a\": 1})             // {a: 1}</code></pre>"},{"location":"en/reference/functions/#read","title":"<code>read()</code>","text":"<p>Reads a line of text from standard input.</p> <p>Parameters: None</p> <p>Returns: <code>string</code> - The line read (without trailing newline)</p> <pre><code>print(\"What is your name?\")\nvar name = read()\nprint(\"Hello, \" + name + \"!\")\n\n// Input: Ana\n// Output: Hello, Ana!</code></pre>"},{"location":"en/reference/functions/#types-and-conversions","title":"Types and Conversions","text":""},{"location":"en/reference/functions/#typeofvalue","title":"<code>typeof(value)</code>","text":"<p>Gets the type name of a value as text.</p> <p>Parameters: - <code>value</code> - Any value</p> <p>Returns: <code>string</code> - Type name</p> Value Result <code>42</code> <code>\"int\"</code> <code>3.14</code> <code>\"float\"</code> <code>\"hello\"</code> <code>\"string\"</code> <code>true</code> <code>\"bool\"</code> <code>null</code> <code>\"null\"</code> <code>[1, 2]</code> <code>\"list\"</code> <code>{\"a\": 1}</code> <code>\"dict\"</code> function <code>\"function\"</code> instance <code>\"instance\"</code> task <code>\"task\"</code> <pre><code>print(typeof(42))           // int\nprint(typeof(\"hello\"))      // string\nprint(typeof([1, 2, 3]))    // list\n\nfn add(a, b) { return a + b }\nprint(typeof(add))          // function</code></pre>"},{"location":"en/reference/functions/#strvalue","title":"<code>str(value)</code>","text":"<p>Converts any value to its string representation.</p> <p>Parameters: - <code>value</code> - Any value</p> <p>Returns: <code>string</code></p> <pre><code>print(str(42))              // \"42\"\nprint(str(3.14))            // \"3.14\"\nprint(str(true))            // \"true\"\nprint(str([1, 2, 3]))       // \"[1, 2, 3]\"\n\n// Useful for concatenation\nvar age = 25\nprint(\"I am \" + str(age) + \" years old\")</code></pre>"},{"location":"en/reference/functions/#intvalue","title":"<code>int(value)</code>","text":"<p>Converts a value to integer.</p> <p>Parameters: - <code>value</code> - Value to convert (<code>string</code>, <code>float</code>, <code>int</code>, <code>bool</code>)</p> <p>Returns: <code>int</code></p> <p>Errors: If conversion is not possible</p> <p>String values must be valid numeric text (no extra characters).</p> <pre><code>print(int(\"42\"))           // 42\nprint(int(3.7))            // 3 (truncates)\nprint(int(true))           // 1\nprint(int(false))          // 0\n\n// Error\n// int(\"abc\")  // Error: Cannot convert 'abc' to integer</code></pre>"},{"location":"en/reference/functions/#floatvalue","title":"<code>float(value)</code>","text":"<p>Converts a value to float (floating-point number).</p> <p>Parameters: - <code>value</code> - Value to convert (<code>string</code>, <code>float</code>, <code>int</code>)</p> <p>Returns: <code>float</code></p> <p>Errors: If conversion is not possible</p> <p>String values must be valid numeric text (no extra characters).</p> <pre><code>print(float(\"3.14\"))        // 3.14\nprint(float(42))            // 42.0\nprint(float(\"42\"))          // 42.0\n\n// Error\n// float(\"abc\")  // Error: Cannot convert 'abc' to float</code></pre>"},{"location":"en/reference/functions/#collections","title":"Collections","text":""},{"location":"en/reference/functions/#collectionlength","title":"<code>collection.length()</code>","text":"<p>Gets the number of elements in a collection. <code>len()</code> is an alias.</p> <p>For strings, counts Unicode characters (not bytes). ASCII strings use a fast path. <code>substring()</code> and <code>index_of()</code> also use character indices.</p> <p>Receiver: <code>list</code>, <code>dict</code>, <code>tuple</code>, or <code>string</code></p> <p>Returns: <code>int</code> - Number of elements</p> <p>Errors: If type is not supported</p> <pre><code>print([1, 2, 3, 4, 5].length())     // 5\nprint(\"Hello\".length())             // 5\nprint({\"a\": 1, \"b\": 2}.length())    // 2\nprint([].len())                      // 0</code></pre>"},{"location":"en/reference/functions/#listpushvalue","title":"<code>list.push(value)</code>","text":"<p>Appends an element to the end of a list. Modifies the original list.</p> <p>Receiver: <code>list</code></p> <p>Parameters: - <code>value</code> - The value to add</p> <p>Returns: <code>null</code></p> <p>Errors: If receiver is not a list</p> <pre><code>var numbers = [1, 2, 3]\nnumbers.push(4)\nnumbers.push(5)\nprint(numbers)   // [1, 2, 3, 4, 5]\n\nvar mixed = []\nmixed.push(\"text\")\nmixed.push(42)\nmixed.push(true)\nprint(mixed)     // [text, 42, true]</code></pre>"},{"location":"en/reference/functions/#listpop","title":"<code>list.pop()</code>","text":"<p>Removes and returns the last element of a list. Modifies the original list.</p> <p>Receiver: <code>list</code></p> <p>Returns: The removed element</p> <p>Errors: If the list is empty or receiver is not a list</p> <pre><code>var numbers = [1, 2, 3, 4, 5]\nvar last = numbers.pop()\nprint(last)    // 5\nprint(numbers) // [1, 2, 3, 4]\n\n// Simulate a stack\nvar stack = []\nstack.push(\"first\")\nstack.push(\"second\")\nprint(stack.pop())   // second\nprint(stack.pop())   // first</code></pre>"},{"location":"en/reference/functions/#dictkeys","title":"<code>dict.keys()</code>","text":"<p>Gets all keys of a dictionary as a list.</p> <p>Receiver: <code>dict</code></p> <p>Returns: <code>list</code> of <code>string</code> - The keys</p> <p>Errors: If receiver is not a dictionary</p> <pre><code>var person = {\n    \"name\": \"Ana\",\n    \"age\": 25,\n    \"city\": \"Madrid\"\n}\n\nvar k = person.keys()\nprint(k)   // [name, age, city]\n\n// Iterate over keys\nfor key in person.keys() {\n    print(key + \": \" + str(person[key]))\n}</code></pre>"},{"location":"en/reference/functions/#dictvalues","title":"<code>dict.values()</code>","text":"<p>Gets all values of a dictionary as a list.</p> <p>Receiver: <code>dict</code></p> <p>Returns: <code>list</code> - The values</p> <p>Errors: If receiver is not a dictionary</p> <pre><code>var grades = {\n    \"math\": 85,\n    \"physics\": 90,\n    \"chemistry\": 78\n}\n\nvar v = grades.values()\nprint(v)   // [85, 90, 78]\n\n// Calculate average\nvar sum = 0\nfor grade in grades.values() {\n    sum += grade\n}\nvar average = sum / grades.length()\nprint(average)  // 84</code></pre>"},{"location":"en/reference/functions/#collectioncontainsvalue","title":"<code>collection.contains(value)</code>","text":"<p>Checks if a collection contains a value.</p> <p>Receiver: <code>list</code>, <code>dict</code>, or <code>string</code></p> <p>Parameters: - <code>value</code> - The value to search for (for dictionaries, searches keys)</p> <p>Returns: <code>bool</code></p> <p>Errors: If receiver type is not supported</p> <pre><code>// In lists\nvar numbers = [1, 2, 3, 4, 5]\nprint(numbers.contains(3))      // true\nprint(numbers.contains(10))     // false\n\n// In dictionaries (searches keys)\nvar person = {\"name\": \"Ana\", \"age\": 25}\nprint(person.contains(\"name\"))  // true\nprint(person.contains(\"height\"))  // false\n\n// In strings (searches substring)\nvar message = \"Hello World\"\nprint(message.contains(\"World\"))   // true\nprint(message.contains(\"Goodbye\")) // false</code></pre>"},{"location":"en/reference/functions/#advanced-functions","title":"Advanced Functions","text":""},{"location":"en/reference/functions/#memoizefunction","title":"<code>memoize(function)</code>","text":"<p>Creates a memoized version of a function. The memoized function caches results to avoid repeated calculations.</p> <p>Parameters: - <code>function</code> - The function to memoize</p> <p>Returns: A new function with cache</p> <p>Errors: If argument is not a function</p> <pre><code>// Fibonacci without memoization (slow for large numbers)\nfn fib(n) {\n    if n &lt;= 1 {\n        return n\n    }\n    return fib(n - 1) + fib(n - 2)\n}\n\n// Fibonacci with memoization (fast)\nvar fib_memo = memoize(fib)\n\nprint(fib_memo(40))  // Fast thanks to cache</code></pre>"},{"location":"en/reference/functions/#memoize-decorator","title":"<code>@memoize</code> Decorator","text":"<p>You can also use the <code>@memoize</code> decorator to apply memoization automatically:</p> <pre><code>@memoize\nfn fibonacci(n) {\n    if n &lt;= 1 {\n        return n\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nprint(fibonacci(50))  // Efficient thanks to memoization</code></pre>"},{"location":"en/reference/functions/#compiler-hints","title":"Compiler Hints","text":""},{"location":"en/reference/functions/#inlinefunction","title":"<code>inline(function)</code>","text":"<p>Hints to the native compiler that a function should be inlined at call sites. This is a no-op in the interpreter but can improve performance in compiled code for small, frequently called functions.</p> <p>Parameters: - <code>function</code> - The function to inline</p> <p>Returns: The function itself</p>"},{"location":"en/reference/functions/#inline-decorator","title":"<code>@inline</code> Decorator","text":"<p>The standard way to use this feature is via the decorator:</p> <pre><code>@inline\nfn add(a, b) {\n    return a + b\n}\n\n// In compiled code, this call is replaced by the addition instruction directly\nvar sum = add(10, 20)</code></pre>"},{"location":"en/reference/functions/#math-functions_1","title":"Math Functions","text":"<p>Math builtins accept integers or floats. <code>min</code>/<code>max</code> accept either two numbers or a list. <code>pi()</code> and <code>e()</code> return constants (also available as <code>PI</code>/<code>E</code> in the interpreter).</p> <pre><code>print(sqrt(9))        // 3\nprint(min([3, 1, 2])) // 1\nprint(pi())           // 3.14159...</code></pre>"},{"location":"en/reference/functions/#string-methods_1","title":"String Methods","text":"<p>String indices are character-based. <code>substring()</code> and <code>index_of()</code> use character indices.</p> <pre><code>print(\"hola\".substring(1, 3))   // \"ol\"\nprint(\"cafe\".index_of(\"fe\"))    // 2\nprint(\"cafe\".starts_with(\"ca\")) // true</code></pre>"},{"location":"en/reference/functions/#collection-methods_1","title":"Collection Methods","text":"<p>Collection helpers take a function or lambda. <code>reduce()</code> accepts an optional initial value and <code>sort()</code> accepts an optional comparator.</p> <pre><code>var numbers = [1, 2, 3, 4]\nprint(numbers.map(n =&gt; n * 2))         // [2, 4, 6, 8]\nprint(numbers.filter(n =&gt; n % 2 == 0)) // [2, 4]\nprint(numbers.reduce((a, b) =&gt; a + b, 0)) // 10</code></pre>"},{"location":"en/reference/functions/#practical-examples","title":"Practical Examples","text":""},{"location":"en/reference/functions/#input-validation","title":"Input Validation","text":"<pre><code>fn read_number() {\n    print(\"Enter a number:\")\n    var input = read()\n    return int(input)\n}\n\nfn read_option(options) {\n    var option = read()\n    if options.contains(option) {\n        return option\n    } else {\n        print(\"Invalid option\")\n        return null\n    }\n}</code></pre>"},{"location":"en/reference/functions/#list-processing","title":"List Processing","text":"<pre><code>fn sum_list(list) {\n    var total = 0\n    for n in list {\n        total += n\n    }\n    return total\n}\n\nfn filter_even(list) {\n    var result = []\n    for n in list {\n        if n % 2 == 0 {\n            result.push(n)\n        }\n    }\n    return result\n}\n\nvar numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(sum_list(numbers))        // 55\nprint(filter_even(numbers))     // [2, 4, 6, 8, 10]</code></pre>"},{"location":"en/reference/functions/#see-also","title":"See Also","text":"<ul> <li>Data Types</li> <li>Keywords</li> <li>Operators</li> </ul>"},{"location":"en/reference/grammar/","title":"Crespi Grammar (ANTLR4)","text":"<p>This is a reference grammar for Crespi using ANTLR4 syntax. It mirrors the language as implemented in the Rust parser, including the new <code>if</code> rules (no parentheses) and block-required <code>if</code> expressions.</p> <p>Notes: - Semicolons are optional due to ASI (automatic semicolon insertion); <code>semi</code> reflects that. - Language packs provide localized keyword/operator aliases; this grammar uses canonical English forms. - String interpolation (<code>$ident</code> and <code>${expr}</code>) is handled by the lexer with modes in practice. The lexer   rules below treat strings as single tokens for simplicity. - Import aliases use <code>as</code> in canonical syntax; Spanish <code>como</code> is accepted at runtime.</p> <pre><code>grammar Crespi;\n\n// ===== Parser rules =====\n\nprogram\n  : statement* EOF\n  ;\n\nstatement\n  : declaration\n  | ifStmt\n  | whenStmt\n  | whileStmt\n  | forStmt\n  | guardStmt\n  | returnStmt\n  | breakStmt\n  | continueStmt\n  | block\n  | exprStmt\n  ;\n\ndeclaration\n  : importDecl\n  | decorator* visibility? (varDecl | letDecl | functionDecl | extensionFunctionDecl | classDecl | traitDecl)\n  | extensionDecl\n  ;\n\nvisibility\n  : 'public' | 'private' | 'internal' | 'fileprivate'\n  ;\n\ndecorator\n  : '@' IDENTIFIER\n  ;\n\nvarDecl\n  : 'var' IDENTIFIER typeAnn? ('=' expression)? semi\n  ;\n\nletDecl\n  : 'let' IDENTIFIER typeAnn? '=' expression semi\n  ;\n\nfunctionDecl\n  : 'async'? 'fn' IDENTIFIER typeParams? '(' parameters? ')' returnType? (block | '=' expression semi)\n  ;\n\nextensionFunctionDecl\n  : 'async'? 'fn' IDENTIFIER '.' IDENTIFIER typeParams? '(' parameters? ')' returnType? (block | '=' expression semi)\n  ;\n\noperatorDecl\n  : 'operator' operatorName '(' parameters? ')' returnType? (block | '=' expression semi)\n  ;\n\nconstructorDecl\n  : 'constructor' '(' parameters? ')' (':' constructorDelegation)? block\n  ;\n\nconstructorDelegation\n  : 'this' '(' arguments? ')'\n  | 'super' '(' arguments? ')'\n  ;\n\nclassDecl\n  : 'class' IDENTIFIER typeParams? ('(' parameters? ')')? (':' parents)? classBody?\n  ;\n\nparents\n  : IDENTIFIER ('(' arguments? ')')? (',' IDENTIFIER)*\n  ;\n\nclassBody\n  : '{' classMember* '}'\n  ;\n\nclassMember\n  : functionDecl\n  | operatorDecl\n  | constructorDecl\n  | varDecl\n  | letDecl\n  | staticMember\n  ;\n\nstaticMember\n  : 'static' functionDecl\n  | 'static' varDecl\n  | 'static' letDecl\n  | 'static' block\n  ;\n\ntraitDecl\n  : 'trait' IDENTIFIER typeParams? (':' parents)? '{' traitMember* '}'\n  ;\n\ntraitMember\n  : 'async'? 'fn' IDENTIFIER '(' parameters? ')' returnType? block?\n  ;\n\nextensionDecl\n  : 'extension' IDENTIFIER (':' parents)? '{' extensionMember* '}'\n  ;\n\nextensionMember\n  : functionDecl\n  | operatorDecl\n  ;\n\nimportDecl\n  : 'import' importKind? modulePath importAlias? importSymbols? semi\n  ;\n\nimportKind\n  : 'fn' | 'class' | 'let' | 'var'\n  ;\n\nimportAlias\n  : 'as' IDENTIFIER\n  ;\n\nimportSymbols\n  : '{' importSymbol (',' importSymbol)* '}'\n  ;\n\nimportSymbol\n  : IDENTIFIER importAlias?\n  ;\n\nmodulePath\n  : IDENTIFIER ('.' IDENTIFIER)*\n  ;\n\nparameters\n  : parameter (',' parameter)*\n  ;\n\nparameter\n  : IDENTIFIER typeAnn? ('=' expression)?\n  ;\n\ntypeParams\n  : '[' typeParam (',' typeParam)* ']'\n  ;\n\ntypeParam\n  : IDENTIFIER (':' typeExpr)?\n  ;\n\ntypeAnn\n  : ':' typeExpr\n  ;\n\nreturnType\n  : '-&gt;' typeExpr\n  ;\n\nifStmt\n  : 'if' expression block ('else' (ifStmt | block))?\n  ;\n\nguardStmt\n  : 'guard' (guardBind | expression) 'else' blockExpr semi?\n  ;\n\nguardBind\n  : 'var' IDENTIFIER '=' expression\n  ;\n\nwhenStmt\n  : 'when' expression '{' whenCase* defaultCase? '}'\n  ;\n\nwhenCase\n  : 'is' pattern '=&gt;' block\n  ;\n\ndefaultCase\n  : 'default' '=&gt;' block\n  ;\n\nwhileStmt\n  : 'while' expression block\n  ;\n\nforStmt\n  : 'for' IDENTIFIER 'in' expression block\n  ;\n\nreturnStmt\n  : 'return' expression? semi\n  ;\n\nbreakStmt\n  : 'break' semi\n  ;\n\ncontinueStmt\n  : 'continue' semi\n  ;\n\nexprStmt\n  : expression semi\n  ;\n\nblock\n  : '{' statement* '}'\n  ;\n\nblockExpr\n  : '{' statement* blockExprTail? '}'\n  ;\n\nblockExprTail\n  : 'return' expression?\n  | expression\n  ;\n\nexpression\n  : assignment\n  ;\n\nassignment\n  : conditional (assignmentOp assignment)?\n  ;\n\nassignmentOp\n  : '=' | '+=' | '-=' | '*=' | '/='\n  ;\n\nconditional\n  : ifExpr\n  | coalesce ('?' expression ':' expression)?\n  ;\n\nifExpr\n  : 'if' expression blockExpr 'else' blockExpr\n  ;\n\ncoalesce\n  : logicalOr ('??' logicalOr)*\n  ;\n\nlogicalOr\n  : logicalAnd (('or' | '||') logicalAnd)*\n  ;\n\nlogicalAnd\n  : bitwiseOr (('and' | '&amp;&amp;') bitwiseOr)*\n  ;\n\nbitwiseOr\n  : bitwiseXor ('|' bitwiseXor)*\n  ;\n\nbitwiseXor\n  : bitwiseAnd ('^' bitwiseAnd)*\n  ;\n\nbitwiseAnd\n  : equality ('&amp;' bitwiseAnd)*\n  ;\n\nequality\n  : comparison (('==' | '!=') comparison)*\n  ;\n\ncomparison\n  : shift (('&lt;' | '&lt;=' | '&gt;' | '&gt;=' | 'in') shift)*\n  ;\n\nshift\n  : term (('&lt;&lt;' | '&gt;&gt;') term)*\n  ;\n\nterm\n  : factor (('+' | '-') factor)*\n  ;\n\nfactor\n  : unary (('*' | '/' | '%') unary)*\n  ;\n\nunary\n  : ('!' | '-' | '~' | 'await') unary\n  | call\n  ;\n\ncall\n  : primary callSuffix*\n  ;\n\ncallSuffix\n  : '(' arguments? ')'\n  | '.' IDENTIFIER\n  | '[' expression ']'\n  | '++'\n  | '--'\n  ;\n\narguments\n  : expression (',' expression)*\n  ;\n\nprimary\n  : literal\n  | IDENTIFIER\n  | 'this'\n  | 'super' '.' IDENTIFIER\n  | lambdaExpr\n  | tupleLiteral\n  | '(' expression ')'\n  | arrayLiteral\n  | dictLiteral\n  ;\n\nlambdaExpr\n  : 'async'? IDENTIFIER '=&gt;' lambdaBody\n  | 'async'? '(' parameters? ')' returnType? '=&gt;' lambdaBody\n  ;\n\nlambdaBody\n  : block\n  | expression\n  ;\n\ntupleLiteral\n  : '(' expression ',' (expression (',' expression)*)? ','? ')'\n  ;\n\narrayLiteral\n  : '[' (expression (',' expression)*)? ']'\n  ;\n\ndictLiteral\n  : '{' (dictEntry (',' dictEntry)*)? '}'\n  ;\n\ndictEntry\n  : (IDENTIFIER | STRING) ':' expression\n  ;\n\npattern\n  : '_'\n  | IDENTIFIER patternClass?\n  | literal\n  | listPattern\n  | dictPattern\n  ;\n\npatternClass\n  : '{' patternField (',' patternField)* '}'\n  ;\n\npatternField\n  : IDENTIFIER ':' pattern\n  ;\n\nlistPattern\n  : '[' (pattern (',' pattern)*)? ']'\n  ;\n\ndictPattern\n  : '{' (patternEntry (',' patternEntry)*)? '}'\n  ;\n\npatternEntry\n  : (IDENTIFIER | STRING) ':' pattern\n  ;\n\noperatorName\n  : '+' | '-' | '*' | '/' | '%'\n  | '==' | '!' | '&lt;' | '&lt;=&gt;'\n  | 'compare' | 'negate' | 'not'\n  | 'increment' | 'decrement'\n  | 'get' | 'set' | 'contains' | 'invoke'\n  ;\n\ntypeExpr\n  : unionType\n  ;\n\nunionType\n  : nullableType ('|' nullableType)*\n  ;\n\nnullableType\n  : primaryType '?'?\n  ;\n\nprimaryType\n  : arrayType\n  | dictType\n  | functionType\n  | tupleType\n  | namedType\n  ;\n\nnamedType\n  : IDENTIFIER ('[' typeExpr (',' typeExpr)* ']')? ('.' '(' parameters? ')' '-&gt;' typeExpr)?\n  ;\n\narrayType\n  : '[' typeExpr ']'\n  ;\n\ndictType\n  : '{' typeExpr ':' typeExpr '}'\n  ;\n\nfunctionType\n  : '(' typeExpr (',' typeExpr)* ')' '-&gt;' typeExpr\n  ;\n\ntupleType\n  : '(' typeExpr (',' typeExpr)+ ')'\n  ;\n\nsemi\n  : ';'?\n  ;\n\n// ===== Lexer rules =====\n\nSTRING\n  : TRIPLE_QUOTED\n  | DOUBLE_QUOTED\n  ;\n\nfragment ESC\n  : '\\\\' [ntr\"\\\\$]\n  ;\n\nDOUBLE_QUOTED\n  : '\"' (ESC | ~[\"\\\\])* '\"'\n  ;\n\nTRIPLE_QUOTED\n  : '\"\"\"' .*? '\"\"\"'\n  ;\n\nDECIMAL\n  : [0-9]+ '.' [0-9]+\n  ;\n\nINTEGER\n  : [0-9]+\n  ;\n\nIDENTIFIER\n  : [a-zA-Z_] [a-zA-Z0-9_]*\n  ;\n\nWS\n  : [ \\t\\r\\n]+ -&gt; skip\n  ;\n\nLINE_COMMENT\n  : '//' ~[\\r\\n]* -&gt; skip\n  ;\n\nBLOCK_COMMENT\n  : '/*' .*? '*/' -&gt; skip\n  ;</code></pre>"},{"location":"en/reference/keywords/","title":"Keywords","text":"<p>Language: Espa\u00f1ol | English</p> <p>Crespi has reserved words that cannot be used as identifiers. English keywords are canonical; language packs provide localized aliases that are normalized during lexing.</p>"},{"location":"en/reference/keywords/#reference-table","title":"Reference Table","text":"Keyword Spanish Alias Category Description <code>var</code> <code>variable</code> Declaration Declares a mutable variable <code>let</code> <code>immutable</code> Declaration Declares an immutable constant <code>static</code> <code>estatico</code> Declaration Declares a static member or static initialization block <code>public</code> <code>publico</code> Declaration Public visibility modifier <code>private</code> <code>privado</code> Declaration Private visibility modifier <code>internal</code> <code>interno</code> Declaration Internal visibility modifier <code>fileprivate</code> <code>fileprivate</code> Declaration File-private visibility modifier <code>fn</code> <code>bloque</code> Functions Defines a function <code>async</code> <code>asincrono</code> Async Marks a function as async (returns a <code>Task</code>) <code>await</code> <code>esperar</code> Async Awaits a <code>Task</code> and unwraps its value <code>extern</code> <code>externo</code> Functions Declares an external (FFI) function <code>return</code> <code>resultado</code> Functions Returns a value from a function <code>if</code> <code>si</code> Control Conditional <code>else</code> <code>o</code> Control Alternative in conditional <code>guard</code> <code>asegura</code> Control Guard condition with return <code>when</code> <code>cuando</code> Control Pattern matching <code>is</code> <code>es</code> Control Match arm <code>default</code> <code>defecto</code> Control Match fallback <code>while</code> <code>mientras</code> Control Loop while condition is true <code>for</code> <code>repetir</code> Control For-each loop <code>in</code> <code>en</code> Control Iterator (used with <code>for</code>) <code>break</code> <code>salir</code> Control Exits current loop <code>continue</code> <code>continuar</code> Control Skips to next iteration <code>class</code> <code>tipo</code> OOP Defines a class <code>nested</code> <code>anidado</code> OOP Defines a nested (static) class <code>inner</code> <code>interno</code> OOP Defines an inner class (captures outer instance) <code>trait</code> <code>trait</code> OOP Defines a trait (interface with optional default implementations) <code>extends</code> <code>extiende</code> OOP Reserved (use <code>:</code> for inheritance) <code>implements</code> <code>implementa</code> OOP Reserved (use <code>:</code> for traits) <code>this</code> <code>yo</code> OOP Reference to current instance <code>super</code> <code>super</code> OOP Reference to parent class <code>operator</code> <code>operador</code> OOP Operator overloading <code>import</code> <code>importar</code> Modules Imports a module or symbol <code>extension</code> <code>extension</code> OOP Extends existing types with methods <code>true</code> <code>verdadero</code> Literals Boolean true value <code>false</code> <code>falso</code> Literals Boolean false value <code>null</code> / <code>nil</code> <code>nada</code> Literals Null value <code>and</code> <code>and</code> Logical Logical AND <code>or</code> <code>or</code> Logical Logical OR"},{"location":"en/reference/keywords/#declarations","title":"Declarations","text":""},{"location":"en/reference/keywords/#visibility-modifiers","title":"Visibility modifiers","text":"<p>Visibility controls how top-level symbols can be imported from other files:</p> <ul> <li><code>public</code> (default): accessible everywhere</li> <li><code>internal</code>: accessible only from files in the same directory</li> <li><code>fileprivate</code>: accessible only from the current file (Swift-style)</li> <li><code>private</code>: same as <code>fileprivate</code> (for backward compatibility)</li> </ul>"},{"location":"en/reference/keywords/#var","title":"<code>var</code>","text":"<p>Declares a mutable variable that can change its value.</p> <pre><code>var counter = 0\ncounter = counter + 1    // OK\nvar name = \"Ana\"\nname = \"Luis\"            // OK</code></pre>"},{"location":"en/reference/keywords/#let","title":"<code>let</code>","text":"<p>Declares an immutable constant. Its value cannot change after initial assignment.</p> <pre><code>let PI = 3.14159\nlet MAX_ATTEMPTS = 3\n\n// PI = 3.0    // Error: cannot reassign a constant</code></pre>"},{"location":"en/reference/keywords/#static","title":"<code>static</code>","text":"<p>Declares a static method, static field, or static initialization block inside a class.</p> <pre><code>class Config {\n    static let version = \"1.0\"\n    static { print(Config.version) }\n}</code></pre>"},{"location":"en/reference/keywords/#functions","title":"Functions","text":""},{"location":"en/reference/keywords/#fn","title":"<code>fn</code>","text":"<p>Defines a function. Can have parameters and a body with multiple statements.</p> <pre><code>// Basic function\nfn greet(name) {\n    print(\"Hello, \" + name)\n}\n\n// Function with return\nfn square(x) {\n    return x * x\n}\n\n// Single-expression syntax\nfn double(x) = x * 2\n\n// With default parameters\nfn power(base, exp = 2) {\n    var r = 1\n    for i in [1, 2, 3] {\n        r = r * base\n    }\n    return r\n}</code></pre>"},{"location":"en/reference/keywords/#async","title":"<code>async</code>","text":"<p>Marks a function as asynchronous. Async functions execute eagerly for now and return a <code>Task[T]</code>.</p> <pre><code>async fn get_answer() -&gt; Int {\n    return 42\n}\n\nvar task = get_answer()\nvar value = await task</code></pre> <p>Async also works with lambdas: <code>var f = async x =&gt; x + 1</code>.</p>"},{"location":"en/reference/keywords/#await","title":"<code>await</code>","text":"<p>Unwraps a <code>Task</code> and yields its value. Using <code>await</code> on a non-task is an error.</p> <pre><code>async fn value() -&gt; String { return \"ok\" }\nvar result = await value()</code></pre>"},{"location":"en/reference/keywords/#extern","title":"<code>extern</code>","text":"<p>Declares an external function from a native (Rust/C) library. Used for FFI (Foreign Function Interface).</p> <pre><code>// Bind to a different native symbol name\n#[link_name = \"my_add_impl\"]\nextern fn my_add(a: Int, b: Int) -&gt; Int\nextern fn my_sin(x: Float) -&gt; Float\n\nfn main() {\n    print(my_add(10, 32))  // 42\n}</code></pre> <p>Compile with library: <code>crespic program.crespi -L libmylib.a</code></p>"},{"location":"en/reference/keywords/#return","title":"<code>return</code>","text":"<p>Returns a value from a function and terminates its execution.</p> <pre><code>fn max(a, b) {\n    if a &gt; b {\n        return a\n    }\n    return b\n}\n\nfn factorial(n) {\n    if n &lt;= 1 {\n        return 1\n    }\n    return n * factorial(n - 1)\n}</code></pre>"},{"location":"en/reference/keywords/#control-flow","title":"Control Flow","text":""},{"location":"en/reference/keywords/#if-else","title":"<code>if</code> / <code>else</code>","text":"<p>Conditional structure to execute code based on a condition.</p> <pre><code>var age = 18\n\n// Simple conditional\nif age &gt;= 18 {\n    print(\"Adult\")\n}\n\n// With alternative\nif age &gt;= 18 {\n    print(\"Adult\")\n} else {\n    print(\"Minor\")\n}\n\n// Multiple conditions\nif age &gt;= 65 {\n    print(\"Retired\")\n} else if age &gt;= 18 {\n    print(\"Adult\")\n} else if age &gt;= 13 {\n    print(\"Teenager\")\n} else {\n    print(\"Child\")\n}</code></pre>"},{"location":"en/reference/keywords/#while","title":"<code>while</code>","text":"<p>Loop that executes while the condition is true.</p> <pre><code>var i = 0\n\nwhile i &lt; 5 {\n    print(i)\n    i += 1\n}\n// Output: 0, 1, 2, 3, 4</code></pre>"},{"location":"en/reference/keywords/#for-in","title":"<code>for</code> / <code>in</code>","text":"<p>Loop to iterate over elements of a collection.</p> <pre><code>// Iterate over list\nvar numbers = [1, 2, 3, 4, 5]\nfor n in numbers {\n    print(n * 2)\n}\n\n// Iterate over text\nvar word = \"Hello\"\nfor letter in word {\n    print(letter)\n}</code></pre>"},{"location":"en/reference/keywords/#break","title":"<code>break</code>","text":"<p>Terminates the current loop immediately.</p> <pre><code>var numbers = [1, 2, 3, 4, 5]\n\nfor n in numbers {\n    if n == 3 {\n        break\n    }\n    print(n)\n}\n// Output: 1, 2</code></pre>"},{"location":"en/reference/keywords/#continue","title":"<code>continue</code>","text":"<p>Skips to the next loop iteration.</p> <pre><code>var numbers = [1, 2, 3, 4, 5]\n\nfor n in numbers {\n    if n == 3 {\n        continue\n    }\n    print(n)\n}\n// Output: 1, 2, 4, 5</code></pre>"},{"location":"en/reference/keywords/#object-oriented-programming","title":"Object-Oriented Programming","text":""},{"location":"en/reference/keywords/#class","title":"<code>class</code>","text":"<p>Defines a class with properties and methods.</p> <pre><code>class Person(let name, let age) {\n    fn introduce() {\n        print(\"I am \" + this.name + \", \" + str(this.age) + \" years old\")\n    }\n}\n\nvar p = Person(\"Ana\", 25)\np.introduce()  // I am Ana, 25 years old</code></pre>"},{"location":"en/reference/keywords/#inheritance","title":"<code>:</code> (inheritance)","text":"<p>Indicates that a class inherits from another class or implements traits.</p> <pre><code>class Animal(let name) {\n    fn speak() {\n        print(this.name + \" makes a sound\")\n    }\n}\n\nclass Dog(let name, let breed) : Animal(name) {\n    fn speak() {\n        print(this.name + \" barks\")\n    }\n}\n\nvar fido = Dog(\"Fido\", \"Labrador\")\nfido.speak()  // Fido barks</code></pre>"},{"location":"en/reference/keywords/#this","title":"<code>this</code>","text":"<p>Reference to the current instance within a method.</p> <pre><code>class Counter {\n    constructor() {\n        this.value = 0\n    }\n\n    fn increment() {\n        this.value += 1\n    }\n\n    fn get() {\n        return this.value\n    }\n}</code></pre>"},{"location":"en/reference/keywords/#super","title":"<code>super</code>","text":"<p>Accesses methods of the parent class.</p> <pre><code>class Vehicle(let brand) {\n}\n\nclass Car(let brand, let model) : Vehicle(brand) {  // Calls Vehicle's constructor\n}</code></pre>"},{"location":"en/reference/keywords/#operator","title":"<code>operator</code>","text":"<p>Defines operator overloading for custom types.</p> <pre><code>class Vector(let x, let y) {\n    operator +(other) {\n        return Vector(this.x + other.x, this.y + other.y)\n    }\n\n    operator ==(other) {\n        return this.x == other.x &amp;&amp; this.y == other.y\n    }\n}\n\nvar v1 = Vector(1, 2)\nvar v2 = Vector(3, 4)\nvar v3 = v1 + v2  // Vector(4, 6)</code></pre>"},{"location":"en/reference/keywords/#modules-and-extensions","title":"Modules and Extensions","text":""},{"location":"en/reference/keywords/#import","title":"<code>import</code>","text":"<p>Imports a module and optionally brings specific symbols into scope. Use <code>{ ... }</code> for direct access without the module prefix.</p> <pre><code>import Math.Vector\nimport Helper { double, Point }\nimport Helper as H { double }\nimport fn Utils.format\nimport class Math.Point</code></pre>"},{"location":"en/reference/keywords/#extension","title":"<code>extension</code>","text":"<p>Adds methods to existing types. Extension targets use runtime type names; English is canonical and language packs may provide aliases like <code>Texto</code>, <code>Entero</code>, <code>Lista</code>.</p> <pre><code>extension Texto {\n    fn shout() = uppercase(this) + \"!\"\n}</code></pre>"},{"location":"en/reference/keywords/#literals","title":"Literals","text":""},{"location":"en/reference/keywords/#true-false","title":"<code>true</code> / <code>false</code>","text":"<p>Boolean values.</p> <pre><code>var active = true\nvar finished = false\n\nif active &amp;&amp; !finished {\n    print(\"In progress\")\n}</code></pre>"},{"location":"en/reference/keywords/#null","title":"<code>null</code>","text":"<p>Represents the absence of a value. <code>nil</code> is an alias.</p> <pre><code>var result = null\n\nfn find(list, value) {\n    for item in list {\n        if item == value {\n            return item\n        }\n    }\n    return null\n}\n\nvar found = find([1, 2, 3], 5)\nif found == null {\n    print(\"Not found\")\n}</code></pre>"},{"location":"en/reference/keywords/#see-also","title":"See Also","text":"<ul> <li>Operators</li> <li>Built-in Functions</li> <li>Data Types</li> </ul>"},{"location":"en/reference/operators/","title":"Operators","text":"<p>Language: Espa\u00f1ol | English</p> <p>Crespi supports operators in symbolic form. With Spanish language pack, textual aliases are also available.</p>"},{"location":"en/reference/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"Symbol Spanish Alias Description Example <code>+</code> <code>mas</code> Addition <code>5 + 3</code> <code>-</code> <code>menos</code> Subtraction <code>10 - 4</code> <code>*</code> <code>por</code> Multiplication <code>6 * 7</code> <code>/</code> <code>entre</code> Division <code>20 / 4</code> <code>%</code> <code>modulo</code> Modulo (remainder) <code>17 % 5</code>"},{"location":"en/reference/operators/#examples","title":"Examples","text":"<pre><code>var a = 10\nvar b = 3\n\nprint(a + b)       // 13\nprint(a - b)       // 7\nprint(a * b)       // 30\nprint(a / b)       // 3 (integer division if both are integers)\nprint(a % b)       // 1</code></pre>"},{"location":"en/reference/operators/#division","title":"Division","text":"<p>Division between integers produces an integer (integer division). To get a decimal, at least one operand must be decimal:</p> <pre><code>print(10 / 3)      // 3 (integer division)\nprint(10.0 / 3)    // 3.333... (decimal division)\nprint(10 / 3.0)    // 3.333... (decimal division)</code></pre>"},{"location":"en/reference/operators/#comparison-operators","title":"Comparison Operators","text":"Symbol Spanish Alias Description Example <code>&lt;</code> <code>menorQue</code> Less than <code>3 &lt; 5</code> <code>&gt;</code> <code>mayorQue</code> Greater than <code>5 &gt; 3</code> <code>&lt;=</code> <code>menorOIgual</code> Less or equal <code>3 &lt;= 3</code> <code>&gt;=</code> <code>mayorOIgual</code> Greater or equal <code>5 &gt;= 5</code> <code>==</code> <code>igualA</code> Equal to <code>5 == 5</code> <code>!=</code> <code>diferenteDe</code> Not equal to <code>3 != 5</code>"},{"location":"en/reference/operators/#examples_1","title":"Examples","text":"<pre><code>var x = 10\nvar y = 5\n\n// Numeric comparisons\nprint(x &gt; y)           // true\nprint(x &lt; y)           // false\nprint(x &gt;= 10)         // true\nprint(x == y)          // false\nprint(x != y)          // true</code></pre>"},{"location":"en/reference/operators/#text-comparison","title":"Text Comparison","text":"<pre><code>var name = \"Ana\"\n\nprint(name == \"Ana\")   // true\nprint(name != \"Luis\")  // true</code></pre>"},{"location":"en/reference/operators/#logical-operators","title":"Logical Operators","text":"Symbol Description Example <code>&amp;&amp;</code> Logical AND <code>true &amp;&amp; false</code> <code>\\|\\|</code> Logical OR <code>true \\|\\| false</code> <code>!</code> Negation <code>!true</code> <code>??</code> Null coalescing (uses right if left is <code>null</code>) <code>null ?? 5</code>"},{"location":"en/reference/operators/#short-circuit-evaluation","title":"Short-Circuit Evaluation","text":"<p>The <code>&amp;&amp;</code>, <code>||</code>, and <code>??</code> operators use short-circuit evaluation: - <code>&amp;&amp;</code>: If the first operand is <code>false</code>, the second is not evaluated - <code>||</code>: If the first operand is <code>true</code>, the second is not evaluated - <code>??</code>: If the first operand is not <code>null</code>, the second is not evaluated</p>"},{"location":"en/reference/operators/#examples_2","title":"Examples","text":"<pre><code>// AND - both must be true\nprint(true &amp;&amp; true)   // true\nprint(true &amp;&amp; false)  // false\nprint(false &amp;&amp; true)  // false\n\n// OR - at least one must be true\nprint(true || false)   // true\nprint(false || false)  // false\n\n// NOT - inverts the value\nprint(!true)           // false\nprint(!false)          // true\n\n// NULL COALESCING - fallback for null\nprint(null ?? 5)       // 5\nprint(0 ?? 5)          // 0</code></pre>"},{"location":"en/reference/operators/#bitwise-operators","title":"Bitwise Operators","text":"Symbol Description Example <code>&amp;</code> Bitwise AND <code>5 &amp; 3</code> (= 1) <code>\\|</code> Bitwise OR <code>5 \\| 3</code> (= 7) <code>^</code> Bitwise XOR <code>5 ^ 3</code> (= 6) <code>&lt;&lt;</code> Left shift <code>1 &lt;&lt; 4</code> (= 16) <code>&gt;&gt;</code> Right shift <code>16 &gt;&gt; 2</code> (= 4) <code>~</code> Bitwise NOT (ones' complement) <code>~0</code> (= -1) <p>Bitwise operators work only on integers.</p>"},{"location":"en/reference/operators/#examples_3","title":"Examples","text":"<pre><code>// Bitwise AND - bits that are 1 in both\nprint(5 &amp; 3)    // 1  (101 &amp; 011 = 001)\nprint(15 &amp; 7)   // 7  (1111 &amp; 0111 = 0111)\n\n// Bitwise OR - bits that are 1 in either\nprint(5 | 3)    // 7  (101 | 011 = 111)\nprint(8 | 1)    // 9  (1000 | 0001 = 1001)\n\n// Bitwise XOR - bits that differ\nprint(5 ^ 3)    // 6  (101 ^ 011 = 110)\nprint(10 ^ 10)  // 0  (a ^ a = 0)\n\n// Left shift - multiply by 2^n\nprint(1 &lt;&lt; 4)   // 16 (1 shifted left 4 = 10000)\nprint(3 &lt;&lt; 2)   // 12 (11 shifted left 2 = 1100)\n\n// Right shift - divide by 2^n\nprint(16 &gt;&gt; 2)  // 4  (10000 shifted right 2 = 100)\nprint(15 &gt;&gt; 1)  // 7  (1111 shifted right 1 = 111)\n\n// Bitwise NOT - flip all bits\nprint(~0)       // -1\nprint(~(-1))    // 0\nprint(~~5)      // 5  (double negation returns original)</code></pre>"},{"location":"en/reference/operators/#conditional-operator","title":"Conditional Operator","text":"<p>The ternary operator chooses between two values based on a condition:</p> <pre><code>var age = 20\nvar status = age &gt;= 18 ? \"adult\" : \"minor\"\nprint(status)</code></pre> <p>Alternative form (requires <code>{}</code> blocks and no parentheses in the condition):</p> <pre><code>var status = if age &gt;= 18 { \"adult\" } else { \"minor\" }</code></pre> <p>Block expressions are required for branches. The last statement is the result:</p> <pre><code>var status = if age &gt;= 18 {\n    var label = \"adult\"\n    label\n} else {\n    \"minor\"\n}</code></pre>"},{"location":"en/reference/operators/#guard-guard","title":"Guard (<code>guard</code>)","text":"<p><code>guard</code> enforces an early return if the condition is false. The <code>else { ... }</code> block is an expression block whose last statement becomes the return value.</p> <pre><code>fn divide(a, b) {\n    guard b != 0 else { \"division by zero\" }\n    return a / b\n}</code></pre> <p>Guard-let style binds a value only if it is not <code>null</code>:</p> <pre><code>fn add_one(value) {\n    guard var x = value else { \"null\" }\n    return x + 1\n}</code></pre>"},{"location":"en/reference/operators/#combinations","title":"Combinations","text":"<pre><code>var age = 25\nvar student = true\n\nif age &gt;= 18 &amp;&amp; student {\n    print(\"Adult student\")\n}\n\nif age &lt; 18 || student {\n    print(\"Minor or student\")\n}</code></pre>"},{"location":"en/reference/operators/#increment-and-decrement-operators","title":"Increment and Decrement Operators","text":"<p>Crespi supports postfix increment (<code>++</code>) and decrement (<code>--</code>) operators. These are statement-level operators that modify a variable.</p> Operator Description Example <code>++</code> Postfix increment <code>i++</code> (equivalent to <code>i += 1</code>) <code>--</code> Postfix decrement <code>i--</code> (equivalent to <code>i -= 1</code>) <pre><code>var i = 0\ni++\nprint(i) // 1\ni--\nprint(i) // 0</code></pre>"},{"location":"en/reference/operators/#assignment-operators","title":"Assignment Operators","text":"Operator Description Equivalent <code>=</code> Assignment - <code>+=</code> Add and assign <code>x = x + value</code> <code>-=</code> Subtract and assign <code>x = x - value</code> <code>*=</code> Multiply and assign <code>x = x * value</code> <code>/=</code> Divide and assign <code>x = x / value</code>"},{"location":"en/reference/operators/#examples_4","title":"Examples","text":"<pre><code>var x = 10\n\nx += 5     // x = 15\nx -= 3     // x = 12\nx *= 2     // x = 24\nx /= 4     // x = 6\n\nprint(x)   // 6</code></pre>"},{"location":"en/reference/operators/#unary-negation-operator","title":"Unary Negation Operator","text":"<p>The <code>-</code> operator can be used to negate a number:</p> <pre><code>var positive = 5\nvar negative = -positive\n\nprint(negative)    // -5\nprint(-10)         // -10\nprint(--5)         // 5 (double negation)</code></pre>"},{"location":"en/reference/operators/#access-operators","title":"Access Operators","text":""},{"location":"en/reference/operators/#index-access","title":"Index Access <code>[]</code>","text":"<p>Accesses elements of lists and dictionaries:</p> <pre><code>var list = [10, 20, 30]\nprint(list[0])     // 10\nprint(list[2])     // 30\nprint(list[-1])    // 30 (last element)\n\nvar dict = {\"name\": \"Ana\", \"age\": 25}\nprint(dict[\"name\"])  // Ana</code></pre>"},{"location":"en/reference/operators/#property-access","title":"Property Access <code>.</code>","text":"<p>Accesses properties and methods of objects:</p> <pre><code>class Point(let x, let y) {\n}\n\nvar p = Point(3, 4)\nprint(p.x)    // 3\nprint(p.y)    // 4</code></pre>"},{"location":"en/reference/operators/#function-call","title":"Function Call <code>()</code>","text":"<p>Invokes a function with arguments:</p> <pre><code>fn add(a, b) {\n    return a + b\n}\n\nprint(add(3, 5))   // 8\nprint(add(1, 2))   // 3</code></pre>"},{"location":"en/reference/operators/#operator-precedence","title":"Operator Precedence","text":"<p>From lowest to highest precedence:</p> Level Operators Associativity 1 <code>??</code> (null coalescing) Left 2 <code>or</code>, <code>||</code> Left 3 <code>and</code>, <code>&amp;&amp;</code> Left 4 <code>|</code> (bitwise OR) Left 5 <code>^</code> (bitwise XOR) Left 6 <code>&amp;</code> (bitwise AND) Left 7 <code>==</code>, <code>!=</code> Left 8 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>in</code> Left 9 <code>&lt;&lt;</code>, <code>&gt;&gt;</code> (shift) Left 10 <code>+</code>, <code>-</code> Left 11 <code>*</code>, <code>/</code>, <code>%</code> Left 12 <code>!</code>, <code>-</code> (unary), <code>~</code> (bitwise NOT) Right 13 <code>.</code>, <code>[]</code>, <code>()</code>, <code>++</code>, <code>--</code> Left"},{"location":"en/reference/operators/#precedence-examples","title":"Precedence Examples","text":"<pre><code>// Multiplication before addition\nprint(2 + 3 * 4)     // 14, not 20\n\n// Parentheses to change order\nprint((2 + 3) * 4)   // 20\n\n// AND before OR\nprint(true || false &amp;&amp; false)  // true\n// Equivalent to: true || (false &amp;&amp; false)\n\n// Comparison before logical\nprint(5 &gt; 3 &amp;&amp; 2 &lt; 4)  // true\n// Equivalent to: (5 &gt; 3) &amp;&amp; (2 &lt; 4)</code></pre>"},{"location":"en/reference/operators/#text-concatenation","title":"Text Concatenation","text":"<p>The <code>+</code> operator also concatenates text:</p> <pre><code>var greeting = \"Hello, \" + \"World\"\nprint(greeting)    // Hello, World\n\nvar name = \"Ana\"\nprint(\"Welcome, \" + name + \"!\")  // Welcome, Ana!</code></pre> <p>To concatenate numbers with text, use the <code>str()</code> function:</p> <pre><code>var age = 25\nprint(\"I am \" + str(age) + \" years old\")  // I am 25 years old</code></pre>"},{"location":"en/reference/operators/#see-also","title":"See Also","text":"<ul> <li>Keywords</li> <li>Data Types</li> <li>Built-in Functions</li> </ul>"},{"location":"en/reference/types/","title":"Data Types","text":"<p>Language: Espa\u00f1ol | English</p> <p>Crespi is dynamically typed at runtime, with an optional static type checker that uses type inference. Types are only enforced when you opt into the checker (for example with <code>--check</code>).</p>"},{"location":"en/reference/types/#type-annotations","title":"Type Annotations","text":"<p>Crespi supports type annotations with Rust-style syntax. When the optional checker runs, types are inferred from context.</p>"},{"location":"en/reference/types/#variable-type-annotations","title":"Variable Type Annotations","text":"<pre><code>// With explicit type\nvar name: String = \"Alice\"\nvar age: Int = 25\nvar active: Bool = true\n\n// Type inference (when running the checker)\nvar count = 42           // Inferred: Int\nvar pi = 3.14            // Inferred: Float\nvar list = [1, 2, 3]     // Inferred: List[Int]\n\nMixed-type list literals are inferred as `List[Any]`.\n\nWith the checker enabled, a variable's inferred or annotated type must remain consistent. Without it, reassignment can use any type at runtime.</code></pre>"},{"location":"en/reference/types/#function-type-annotations","title":"Function Type Annotations","text":"<pre><code>// Fully typed function\nfn add(a: Int, b: Int) -&gt; Int {\n    return a + b\n}\n\n// With default values\nfn greet(name: String = \"World\") -&gt; String {\n    return \"Hello, \" + name\n}\n\n// Generic function with constraints\nfn [T: Numeric] max(a: T, b: T) -&gt; T {\n    if a &gt; b { return a }\n    return b\n}</code></pre>"},{"location":"en/reference/types/#nullable-types","title":"Nullable Types","text":"<pre><code>// Nullable type annotation with ?\nvar result: String? = null\n\n// Null coalescing operator\nvar value = result ?? \"default\"</code></pre>"},{"location":"en/reference/types/#union-types","title":"Union Types","text":"<p><pre><code>// Union type annotation with |\nfn parse(input: String) -&gt; Int | Error {\n    // Can return either Int or Error\n}</code></pre> Union types are order-insensitive in the static checker, so <code>Int | String</code> and <code>String | Int</code> are treated as the same type. Values of a member type are assignable to the union (for example, <code>Int</code> can be used where <code>Int | String</code> is expected).</p>"},{"location":"en/reference/types/#class-type-annotations","title":"Class Type Annotations","text":"<pre><code>class Point(let x: Int, let y: Int) {\n    fn distance() -&gt; Float {\n        return sqrt(float(this.x * this.x + this.y * this.y))\n    }\n}</code></pre>"},{"location":"en/reference/types/#generic-types","title":"Generic Types","text":"<pre><code>class Container[T](let value: T) {\n    fn get() -&gt; T {\n        return this.value\n    }\n}</code></pre>"},{"location":"en/reference/types/#type-table","title":"Type Table","text":""},{"location":"en/reference/types/#static-types-for-annotations","title":"Static Types (for annotations)","text":"Type Description Example <code>Int</code> 64-bit signed integer (default) <code>42</code> <code>Int32</code>, <code>Int16</code>, <code>Int8</code> Specific width signed integers <code>100: Int32</code> <code>UInt</code>, <code>UInt32</code>, <code>UInt16</code>, <code>UInt8</code> Unsigned integers <code>50: UInt</code> <code>Double</code> 64-bit floating-point (default) <code>3.14</code> <code>Float</code> 32-bit floating-point <code>3.14: Float</code> <code>String</code> UTF-8 string <code>\"Hello\"</code> <code>Bool</code> True or false value <code>true</code> <code>Null</code> Absence of value <code>null</code> <code>Unit</code> No value (like void) <code>fn f() -&gt; Unit</code> <code>Any</code> Top type (accepts anything) <code>var x: Any</code> <code>Never</code> Bottom type (no values) <code>fn fail() -&gt; Never</code> <code>List[T]</code> Dynamic array of type T <code>[1, 2]: List[Int]</code> <code>(T1, T2)</code> Fixed-size tuple <code>(1, \"a\"): (Int, String)</code> <code>Dict[K, V]</code> Text-keyed map <code>{\"a\": 1}: Dict[String, Int]</code> <code>Task[T]</code> Async task that yields a value of type T <code>Task[Int]</code>"},{"location":"en/reference/types/#runtime-type-names-from-typeof","title":"Runtime Type Names (from <code>typeof()</code>)","text":"Name Values <code>\"int\"</code> All signed/unsigned integers <code>\"float\"</code> <code>Double</code> and <code>Float</code> <code>\"string\"</code> <code>String</code> <code>\"bool\"</code> <code>Bool</code> <code>\"null\"</code> <code>Null</code> <code>\"list\"</code> <code>List[T]</code> <code>\"tuple\"</code> <code>(T1, T2)</code> <code>\"dict\"</code> <code>Dict[K, V]</code> <code>\"function\"</code> Functions and lambdas <code>\"instance\"</code> Class instances <code>\"task\"</code> <code>Task[T]</code> values"},{"location":"en/reference/types/#async-tasks","title":"Async Tasks","text":"<p>Async functions return <code>Task[T]</code>. Tasks are eager: the function executes immediately and the result is wrapped. Use <code>await</code> to unwrap a task value.</p> <pre><code>async fn compute() -&gt; Int { return 10 }\nvar task: Task[Int] = compute()\nvar value = await task</code></pre>"},{"location":"en/reference/types/#numeric-types","title":"Numeric Types","text":"<p>Crespi uses explicit-width numeric types and follows Swift's naming convention for floating-point numbers.</p>"},{"location":"en/reference/types/#integers","title":"Integers","text":"Type Width Range <code>Int</code> 64-bit -9.22e18 to 9.22e18 <code>Int32</code> 32-bit -2.14e9 to 2.14e9 <code>Int16</code> 16-bit -32,768 to 32,767 <code>Int8</code> 8-bit -128 to 127 <code>UInt</code> 64-bit 0 to 1.84e19 <code>UInt32</code> 32-bit 0 to 4.29e9 <code>UInt16</code> 16-bit 0 to 65,535 <code>UInt8</code> 8-bit 0 to 255"},{"location":"en/reference/types/#floating-point","title":"Floating-Point","text":"Type Width Description <code>Double</code> 64-bit Default float type (IEEE 754) <code>Float</code> 32-bit Single precision float"},{"location":"en/reference/types/#strict-typing","title":"Strict Typing","text":"<p>Crespi does not perform implicit numeric coercion. You must use explicit conversion functions or methods if you want to assign an <code>Int32</code> to an <code>Int</code>, or an <code>Int</code> to a <code>Double</code>.</p> <pre><code>var i: Int = 42\nvar d: Double = i.toDouble() // OK\n// var d2: Double = i        // Error: Type mismatch</code></pre>"},{"location":"en/reference/types/#primitive-types","title":"Primitive Types","text":""},{"location":"en/reference/types/#int","title":"<code>int</code>","text":"<p>Signed 64-bit integers. Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.</p> <pre><code>var age = 25\nvar negative = -100\nvar zero = 0\nvar large = 9223372036854775807\n\nprint(typeof(age))  // int</code></pre> <p>Operations: - Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> - Comparison: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></p>"},{"location":"en/reference/types/#float","title":"<code>float</code>","text":"<p>64-bit floating-point numbers (IEEE 754 double precision).</p> <pre><code>var pi = 3.14159\nvar temperature = -5.5\nvar scientific = 1.5e10  // Scientific notation: 1.5 \u00d7 10\u00b9\u2070\n\nprint(typeof(pi))  // float</code></pre> <p>Note on division: <pre><code>print(10 / 3)     // 3 (integer division)\nprint(10.0 / 3)   // 3.333... (float division)\nprint(10 / 3.0)   // 3.333...</code></pre></p>"},{"location":"en/reference/types/#string","title":"<code>string</code>","text":"<p>Immutable character strings encoded in UTF-8.</p> <pre><code>var greeting = \"Hello, World\"\nvar multiline = \"Line 1\nLine 2\"\nvar with_escape = \"Says: \\\"Hello\\\"\"\nvar with_tabs = \"Col1\\tCol2\"\n\nprint(typeof(greeting))   // string\nprint(greeting.length())   // 12</code></pre> <p>Escape sequences: | Sequence | Meaning | |----------|---------| | <code>\\\\</code> | Backslash | | <code>\\\"</code> | Double quote | | <code>\\n</code> | Newline | | <code>\\t</code> | Tab | | <code>\\r</code> | Carriage return | | <code>\\$</code> | Literal dollar sign |</p> <p>String interpolation: <pre><code>var name = \"Ana\"\nvar total = 3\nprint(\"Hello, $name\")            // Hello, Ana\nprint(\"Total: ${total + 1}\")     // Total: 4</code></pre></p> <p>Raw (triple-quoted) strings: <pre><code>var multiline = \"\"\"Line 1\nLine 2\"\"\"\n\nvar price = 5\nprint(\"\"\"Cost: $$${price}\"\"\")   // Cost: $5</code></pre></p> <p>Operations: <pre><code>// Concatenation\nvar full = \"Hello\" + \" \" + \"World\"\n\n// Character access (iteration)\nfor letter in \"ABC\" {\n    print(letter)  // A, B, C\n}\n\n// Search\nprint(\"Hello World\".contains(\"World\"))  // true</code></pre></p>"},{"location":"en/reference/types/#bool","title":"<code>bool</code>","text":"<p>Logical values: <code>true</code> or <code>false</code>.</p> <pre><code>var active = true\nvar finished = false\n\nprint(typeof(active))  // bool</code></pre> <p>Truthiness (conversion to boolean):</p> Type Falsy Value Truthy Value <code>bool</code> <code>false</code> <code>true</code> <code>int</code> <code>0</code> Any other <code>float</code> <code>0.0</code> Any other <code>string</code> <code>\"\"</code> (empty) Non-empty <code>list</code> <code>[]</code> (empty) Non-empty <code>tuple</code> (no empty literal) Always truthy <code>null</code> Always - <pre><code>// In conditions\nif 1 { print(\"true\") }      // Executes\nif 0 { print(\"not seen\") }  // Does not execute\nif \"hello\" { print(\"yes\") } // Executes\nif \"\" { print(\"no\") }       // Does not execute</code></pre>"},{"location":"en/reference/types/#null","title":"<code>null</code>","text":"<p>Represents the absence of a value. Similar to <code>null</code> or <code>nil</code> in other languages.</p> <pre><code>var result = null\n\nfn find(list, target) {\n    for item in list {\n        if item == target {\n            return item\n        }\n    }\n    return null\n}\n\nvar found = find([1, 2, 3], 5)\nif found == null {\n    print(\"Not found\")\n}</code></pre>"},{"location":"en/reference/types/#collection-types","title":"Collection Types","text":""},{"location":"en/reference/types/#list","title":"<code>list</code>","text":"<p>Dynamic array that can contain elements of any type.</p> <pre><code>// Creation\nvar empty = []\nvar numbers = [1, 2, 3, 4, 5]\nvar mixed = [1, \"two\", true, null, [1, 2]]\n\nprint(typeof(numbers))  // list</code></pre> <p>Element access: <pre><code>var list = [10, 20, 30, 40, 50]\n\n// Positive indices (from start)\nprint(list[0])   // 10 (first element)\nprint(list[2])   // 30\n\n// Negative indices (from end)\nprint(list[-1])  // 50 (last element)\nprint(list[-2])  // 40</code></pre></p>"},{"location":"en/reference/types/#tuple","title":"<code>tuple</code>","text":"<p>Fixed-size ordered collection. Tuples use parentheses with commas, and a single-element tuple requires a trailing comma.</p> <pre><code>var point = (3, 4)\nvar single = (1,)\n\nprint(typeof(point))    // tuple\nprint(point.length())    // 2\nprint(point[0])         // 3\nprint(point[-1])        // 4</code></pre> <p>Modification: <pre><code>var list = [1, 2, 3]\n\n// Modify element\nlist[0] = 100\nprint(list)  // [100, 2, 3]\n\n// Append to end\nlist.push(4)\nprint(list)  // [100, 2, 3, 4]\n\n// Remove from end\nvar last = list.pop()\nprint(last)  // 4\nprint(list)  // [100, 2, 3]</code></pre></p> <p>Iteration: <pre><code>var colors = [\"red\", \"green\", \"blue\"]\n\nfor color in colors {\n    print(color)\n}</code></pre></p>"},{"location":"en/reference/types/#dict","title":"<code>dict</code>","text":"<p>Text-keyed map to values of any type.</p> <pre><code>// Creation\nvar empty = {}\nvar person = {\n    \"name\": \"Ana\",\n    \"age\": 25,\n    \"active\": true\n}\n\nprint(typeof(person))  // dict</code></pre> <p>Value access: <pre><code>var dict = {\"a\": 1, \"b\": 2, \"c\": 3}\n\nprint(dict[\"a\"])    // 1\nprint(dict[\"b\"])    // 2</code></pre></p> <p>Modification: <pre><code>var config = {\"theme\": \"dark\"}\n\n// Modify existing value\nconfig[\"theme\"] = \"light\"\n\n// Add new key\nconfig[\"language\"] = \"en\"\n\nprint(config)  // {theme: light, language: en}</code></pre></p> <p>Iteration: <pre><code>var grades = {\"math\": 90, \"physics\": 85, \"chemistry\": 78}\n\n// Iterate over keys\nfor subject in grades.keys() {\n    print(subject + \": \" + str(grades[subject]))\n}\n\n// Get values\nvar vals = grades.values()\nprint(vals)  // [90, 85, 78]</code></pre></p>"},{"location":"en/reference/types/#callable-types","title":"Callable Types","text":""},{"location":"en/reference/types/#function","title":"<code>function</code>","text":"<p>User-defined functions.</p> <pre><code>// Standard declaration\nfn add(a, b) {\n    return a + b\n}\n\n// Short syntax (single expression)\nfn double(x) = x * 2\n\n// With default values\nfn greet(name = \"World\") {\n    print(\"Hello, \" + name)\n}\n\nprint(typeof(add))  // function</code></pre> <p>Functions as values: <pre><code>// Assign to variable\nvar operation = add\nprint(operation(3, 4))  // 7\n\n// Pass as argument\nfn apply(fn, value) {\n    return fn(value)\n}\nprint(apply(double, 5))  // 10\n\n// Return function\nfn create_multiplier(factor) {\n    fn multiply(x) {\n        return x * factor\n    }\n    return multiply\n}\nvar triple = create_multiplier(3)\nprint(triple(4))  // 12</code></pre></p>"},{"location":"en/reference/types/#class","title":"<code>class</code>","text":"<p>Definition of a type with constructor and methods.</p> <pre><code>class Counter(var value = 0) {\n    fn increment() {\n        this.value += 1\n    }\n\n    fn get() {\n        return this.value\n    }\n}\n\nprint(typeof(Counter))  // class</code></pre>"},{"location":"en/reference/types/#instance","title":"<code>instance</code>","text":"<p>Object created from a class.</p> <pre><code>class Point(let x, let y) {\n}\n\nvar p = Point(3, 4)\nprint(typeof(p))  // instance\n\n// Property access\nprint(p.x)  // 3\nprint(p.y)  // 4</code></pre>"},{"location":"en/reference/types/#type-checking","title":"Type Checking","text":"<p>Use <code>typeof()</code> to check a value's type:</p> <pre><code>fn is_number(value) {\n    var t = typeof(value)\n    return t == \"int\" || t == \"float\"\n}\n\nfn is_collection(value) {\n    var t = typeof(value)\n    return t == \"list\" || t == \"dict\"\n}\n\nprint(is_number(42))         // true\nprint(is_number(3.14))       // true\nprint(is_number(\"42\"))       // false\n\nprint(is_collection([1,2]))   // true\nprint(is_collection({\"a\":1})) // true</code></pre>"},{"location":"en/reference/types/#type-conversion","title":"Type Conversion","text":"Function Accepted Types Result <code>str()</code> Any <code>string</code> <code>int()</code> <code>string</code>, <code>float</code>, <code>int</code>, <code>bool</code> <code>int</code> <code>float()</code> <code>string</code>, <code>float</code>, <code>int</code> <code>float</code> <pre><code>// To string\nprint(str(42))           // \"42\"\nprint(str(3.14))         // \"3.14\"\nprint(str(true))         // \"true\"\nprint(str([1, 2]))       // \"[1, 2]\"\n\n// To integer\nprint(int(\"42\"))         // 42\nprint(int(3.7))          // 3 (truncates)\nprint(int(true))         // 1\nprint(int(false))        // 0\n\n// To float\nprint(float(\"3.14\"))     // 3.14\nprint(float(42))         // 42.0</code></pre>"},{"location":"en/reference/types/#see-also","title":"See Also","text":"<ul> <li>Keywords</li> <li>Operators</li> <li>Built-in Functions</li> </ul>"},{"location":"es/","title":"Crespi - Documentacion","text":"<p>Idioma: Espanol | English</p> <p>Crespi es un lenguaje de programacion multilingue (mediante paquetes de idioma), disenado para hacer la programacion mas accesible. El espanol es el primer paquete de idioma, con arquitectura preparada para idiomas adicionales.</p>"},{"location":"es/#contenido","title":"Contenido","text":""},{"location":"es/#inicio","title":"Inicio","text":"<ul> <li>Inicio Rapido - Tu primer programa en Crespi</li> </ul>"},{"location":"es/#referencia-del-lenguaje","title":"Referencia del Lenguaje","text":"<ul> <li>Palabras Clave - Todas las palabras reservadas</li> <li>Operadores - Operadores aritmeticos, de comparacion y logicos</li> <li>Funciones Integradas - Funciones disponibles por defecto</li> <li>Tipos de Datos - Sistema de tipos de Crespi</li> <li>Gramatica (ANTLR4) - Gramatica de referencia</li> <li>FFI - Interfaz de Funciones Foraneas</li> </ul>"},{"location":"es/#ejecucion","title":"Ejecucion","text":"<ul> <li>Interprete - Ejecutar codigo directamente</li> <li>Compilador - Compilar a ejecutable nativo</li> <li>Paridad de Funcionalidades - Matriz interprete vs compilador</li> </ul>"},{"location":"es/#arquitectura","title":"Arquitectura","text":"<ul> <li>Vision General - Arquitectura de alto nivel</li> <li>Estructura de Crates - Organizacion de crates Rust</li> </ul>"},{"location":"es/#contribuir","title":"Contribuir","text":"<ul> <li>Guia de Contribucion - Como contribuir</li> <li>Estilo de Codigo - Estandares de codificacion</li> </ul>"},{"location":"es/#guia-del-lenguaje","title":"Guia del Lenguaje","text":"<ul> <li>Variables y Constantes</li> <li>Control de Flujo</li> <li>Funciones</li> <li>Listas y Diccionarios</li> <li>Clases y Objetos</li> <li>Caracteristicas Avanzadas</li> </ul>"},{"location":"es/#caracteristicas-principales","title":"Caracteristicas Principales","text":""},{"location":"es/#sintaxis-multilingue","title":"Sintaxis Multilingue","text":"<p>Crespi soporta sintaxis en multiples idiomas mediante paquetes de idioma. El espanol es el primer paquete disponible:</p> <pre><code>variable nombre = \"Ana\"\nimmutable PI = 3.14159\n\nsi nombre igualA \"Ana\" {\n    mostrar(\"Hola, Ana!\")\n}</code></pre>"},{"location":"es/#sistema-de-tipos","title":"Sistema de Tipos","text":"<p>Crespi utiliza tipado estatico con inferencia de tipos estilo Hindley-Milner. Las anotaciones de tipo son opcionales gracias a la inferencia, pero el sistema subyacente es estatico:</p> <ul> <li>Compilador: Verificacion de tipos estricta - los errores bloquean la compilacion</li> <li>Interprete: Modo relajado - los errores de tipo aparecen como advertencias pero la ejecucion continua</li> </ul>"},{"location":"es/#operadores-legibles","title":"Operadores Legibles","text":"<p>Crespi permite usar operadores en forma simbolica o textual:</p> <pre><code>// Forma simbolica\nvariable suma = 5 + 3\n\n// Forma textual (equivalente)\nvariable suma = 5 mas 3</code></pre>"},{"location":"es/#programacion-orientada-a-objetos","title":"Programacion Orientada a Objetos","text":"<pre><code>tipo Persona(immutable nombre, immutable edad) {\n    bloque saludar() {\n        mostrar(\"Hola, soy \" + yo.nombre)\n    }\n}\n\nvariable ana = Persona(\"Ana\", 25)\nana.saludar()</code></pre>"},{"location":"es/#funciones-de-primera-clase","title":"Funciones de Primera Clase","text":"<pre><code>bloque duplicar(x) {\n    resultado x * 2\n}\n\nbloque aplicar(funcion, valor) {\n    resultado funcion(valor)\n}\n\nmostrar(aplicar(duplicar, 5))  // 10</code></pre>"},{"location":"es/#instalacion","title":"Instalacion","text":""},{"location":"es/#requisitos","title":"Requisitos","text":"<ul> <li>Rust 1.70+</li> <li>Cargo</li> </ul>"},{"location":"es/#compilar-desde-fuente","title":"Compilar desde Fuente","text":"<pre><code>git clone https://github.com/usuario/crespi-lang.git\ncd crespi-lang\ncargo build --release</code></pre>"},{"location":"es/#ejecutar","title":"Ejecutar","text":"<pre><code># REPL interactivo\ncargo run\n\n# Ejecutar un archivo\ncargo run -- programa.crespi</code></pre>"},{"location":"es/#recursos","title":"Recursos","text":"<ul> <li>Ejemplos - Programas de ejemplo</li> <li>Soporte IDE - Extension VS Code y LSP</li> <li>Runtime WASM - Bindings de WebAssembly</li> <li>Plataforma Web - Aprende en el navegador</li> </ul>"},{"location":"es/inicio-rapido/","title":"Inicio R\u00e1pido","text":"<p>Idioma: Espa\u00f1ol | English</p> <p>Esta gu\u00eda te ayudar\u00e1 a escribir tu primer programa en Crespi en pocos minutos.</p>"},{"location":"es/inicio-rapido/#hola-mundo","title":"Hola Mundo","text":"<p>El programa m\u00e1s simple en Crespi:</p> <pre><code>mostrar(\"Hola, Mundo!\")</code></pre> <p>Guarda esto en un archivo <code>hola.crespi</code> y ejec\u00fatalo.</p> <p>Crespi ofrece dos formas de ejecutar tu c\u00f3digo:</p> <ul> <li>Int\u00e9rprete - Ejecuta directamente, soporta todas las caracter\u00edsticas</li> <li>Compilador - Compila a ejecutable nativo</li> </ul> <p>Salida: <pre><code>Hola, Mundo!</code></pre></p>"},{"location":"es/inicio-rapido/#variables-y-constantes","title":"Variables y Constantes","text":"<p>Usa <code>variable</code> para valores que pueden cambiar y <code>immutable</code> para valores fijos:</p> <pre><code>variable nombre = \"Mar\u00eda\"\nimmutable PI = 3.14159\n\nmostrar(nombre)     // Mar\u00eda\nmostrar(PI)         // 3.14159\n\nnombre = \"Carlos\"   // OK - variable puede cambiar\n// PI = 3.0         // Error! - immutable no puede cambiar</code></pre>"},{"location":"es/inicio-rapido/#tipos-de-datos-basicos","title":"Tipos de Datos B\u00e1sicos","text":"<pre><code>// N\u00fameros\nvariable entero = 42\nvariable decimal = 3.14\n\n// Texto\nvariable mensaje = \"Hola\"\n\n// Booleanos\nvariable activo = verdadero\nvariable inactivo = falso\n\n// Nulo\nvariable vacio = nada</code></pre>"},{"location":"es/inicio-rapido/#operadores","title":"Operadores","text":"<p>Crespi soporta operadores simb\u00f3licos y textuales:</p> <pre><code>// Aritm\u00e9ticos\nvariable suma = 5 + 3       // o: 5 mas 3\nvariable resta = 10 - 4     // o: 10 menos 4\nvariable producto = 6 * 7   // o: 6 por 7\nvariable cociente = 20 / 4  // o: 20 entre 4\n\n// Comparaci\u00f3n\nvariable mayor = 10 &gt; 5     // o: 10 mayorQue 5\nvariable igual = 5 == 5     // o: 5 igualA 5\n\n// L\u00f3gicos\nvariable ambos = verdadero &amp;&amp; falso   // falso\nvariable alguno = verdadero || falso   // verdadero</code></pre>"},{"location":"es/inicio-rapido/#condicionales","title":"Condicionales","text":"<pre><code>variable edad = 18\n\nsi edad &gt;= 18 {\n    mostrar(\"Mayor de edad\")\n} o {\n    mostrar(\"Menor de edad\")\n}</code></pre> <p>Con m\u00faltiples condiciones:</p> <pre><code>variable nota = 85\n\nsi nota &gt;= 90 {\n    mostrar(\"Excelente\")\n} o si nota &gt;= 70 {\n    mostrar(\"Aprobado\")\n} o {\n    mostrar(\"Reprobado\")\n}</code></pre>"},{"location":"es/inicio-rapido/#bucles","title":"Bucles","text":""},{"location":"es/inicio-rapido/#mientras-while","title":"Mientras (while)","text":"<pre><code>variable contador = 0\n\nmientras contador &lt; 5 {\n    mostrar(contador)\n    contador += 1\n}\n// Salida: 0, 1, 2, 3, 4</code></pre>"},{"location":"es/inicio-rapido/#repetir-for-each","title":"Repetir (for-each)","text":"<pre><code>variable numeros = [1, 2, 3, 4, 5]\n\nrepetir n en numeros {\n    mostrar(n * 2)\n}\n// Salida: 2, 4, 6, 8, 10</code></pre>"},{"location":"es/inicio-rapido/#funciones","title":"Funciones","text":""},{"location":"es/inicio-rapido/#sintaxis-basica","title":"Sintaxis B\u00e1sica","text":"<pre><code>bloque saludar(nombre) {\n    mostrar(\"Hola, \" + nombre + \"!\")\n}\n\nsaludar(\"Ana\")  // Hola, Ana!</code></pre>"},{"location":"es/inicio-rapido/#con-valor-de-retorno","title":"Con Valor de Retorno","text":"<pre><code>bloque cuadrado(x) {\n    resultado x * x\n}\n\nvariable r = cuadrado(5)\nmostrar(r)  // 25</code></pre>"},{"location":"es/inicio-rapido/#sintaxis-corta-expresion-unica","title":"Sintaxis Corta (expresi\u00f3n \u00fanica)","text":"<pre><code>bloque doble(x) = x * 2\nbloque suma(a, b) = a + b\n\nmostrar(doble(7))     // 14\nmostrar(suma(3, 4))   // 7</code></pre>"},{"location":"es/inicio-rapido/#parametros-por-defecto","title":"Par\u00e1metros por Defecto","text":"<pre><code>bloque saludar(nombre = \"Mundo\") {\n    mostrar(\"Hola, \" + nombre)\n}\n\nsaludar()         // Hola, Mundo\nsaludar(\"Ana\")    // Hola, Ana</code></pre>"},{"location":"es/inicio-rapido/#listas-y-diccionarios","title":"Listas y Diccionarios","text":""},{"location":"es/inicio-rapido/#listas","title":"Listas","text":"<pre><code>variable frutas = [\"manzana\", \"naranja\", \"pera\"]\n\nmostrar(frutas[0])           // manzana\nmostrar(frutas.longitud())    // 3\n\nfrutas.agregar(\"uva\")\nmostrar(frutas)              // [manzana, naranja, pera, uva]</code></pre>"},{"location":"es/inicio-rapido/#diccionarios","title":"Diccionarios","text":"<pre><code>variable persona = {\n    \"nombre\": \"Luis\",\n    \"edad\": 30\n}\n\nmostrar(persona[\"nombre\"])   // Luis\npersona[\"ciudad\"] = \"Madrid\"\nmostrar(persona.claves())     // [nombre, edad, ciudad]</code></pre>"},{"location":"es/inicio-rapido/#clases","title":"Clases","text":"<pre><code>tipo Rectangulo(immutable ancho, immutable alto) {\n    bloque area() {\n        resultado yo.ancho * yo.alto\n    }\n}\n\nvariable rect = Rectangulo(5, 3)\nmostrar(rect.area())  // 15</code></pre>"},{"location":"es/inicio-rapido/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Referencia de Palabras Clave</li> <li>Funciones Integradas</li> <li>Ejemplos</li> </ul>"},{"location":"llvm/abi/","title":"Crespi LLVM ABI","text":"<p>Status: Draft (LLVM backend target)</p> <p>This document defines the calling convention and type mapping used by the LLVM backend. It is the source of truth for codegen and runtime interop.</p>"},{"location":"llvm/abi/#calling-convention","title":"Calling Convention","text":"<ul> <li>All compiled Crespi functions (user functions, methods, closures, and the   synthetic <code>main</code>) use C ABI and take a hidden first parameter:   <code>gc_ctx: *mut GcContext</code>.</li> <li>Methods receive the receiver (<code>this</code>) as the first explicit parameter   after <code>gc_ctx</code>.</li> <li>Closures are represented as an opaque runtime object and are invoked   either directly (when the function pointer is known) or via the runtime   helper <code>crespi_rt_call_closure(gc_ctx, closure, args_ptr, arg_count)</code>.</li> <li><code>extern fn</code> declarations map directly to C ABI functions and do NOT   include <code>gc_ctx</code> when all parameter/return types are primitives.</li> <li>If an <code>extern fn</code> uses non-primitive types, the compiler lowers the call   to the native wrapper ABI:   <code>extern \"C\" fn(*mut GcContext, *const CrespiValue, usize) -&gt; CrespiValue</code>.</li> </ul>"},{"location":"llvm/abi/#type-mapping-crespi-llvm-rust","title":"Type Mapping (Crespi -&gt; LLVM -&gt; Rust)","text":"<p>Primitives:</p> Crespi LLVM Rust Notes Int i64 i64 default integer Int32 i32 i32 32-bit signed Int16 i16 i16 16-bit signed Int8 i8 i8 8-bit signed UInt i64 u64 64-bit unsigned UInt32 i32 u32 32-bit unsigned UInt16 i16 u16 16-bit unsigned UInt8 i8 u8 8-bit unsigned Double f64 f64 default float Float f32 f32 32-bit float Bool i8 bool 0/1 Unit i8 () value 0 <p>Note: the LLVM backend currently lowers <code>Float</code> to f64 for internal Crespi functions to match interpreter semantics. Extern signatures still use f32.</p> <p>Heap / reference types use LLVM opaque pointers (<code>ptr</code>) in the default address space (pointer size is target-dependent, 64-bit on supported hosts):</p> Crespi LLVM Rust String ptr *mut String / runtime string object List[T] ptr mut Vec (typed) or mut ListObject Dict[K,V] ptr *mut DictObject class Foo ptr *mut Foo (runtime instance)"},{"location":"llvm/abi/#boxed-values-crespivalue","title":"Boxed Values (<code>CrespiValue</code>)","text":"<p>When the type is unknown or erased (Union, TypeVar, dynamic paths), codegen uses <code>CrespiValue</code>, a <code>#[repr(C)]</code> tagged struct defined in <code>crates/crespi-runtime/src/value.rs</code>.</p> <p><code>CrespiValue</code> layout (64-bit target):</p> <pre><code>#[repr(C)]\nstruct CrespiValue {\n    tag: u8,\n    _padding: [u8; 7],\n    payload: u64,\n}</code></pre> <p>In LLVM IR, the Rust ABI for the struct above is represented as:</p> <pre><code>%CrespiValue = type [2 x i64]</code></pre> <p>The LLVM backend therefore uses <code>[2 x i64]</code> as the in-IR representation:</p> <ul> <li>element 0: tag stored in the low 8 bits (remaining bytes reserved/padding)</li> <li>element 1: payload bits</li> </ul> <p>Tag values: - Null = 0 - Missing = 1 - Bool = 2 - Int = 3 - Float = 4 - Object = 5 - Opaque = 6</p> <p>Payload encoding: - Bool: 0 or 1 - Int: i64 bits (two's complement) - Float: f64 bits (<code>to_bits</code>) - Object/Opaque: pointer value cast to <code>u64</code></p> <p>Size/alignment (64-bit targets): 16 bytes, align 8.</p> <p>Use runtime helpers to box/unbox values at ABI boundaries when needed.</p>"},{"location":"llvm/abi/#nullables-and-unions","title":"Nullables and Unions","text":"<ul> <li><code>Nullable</code>, <code>Union</code>, and <code>TypeVar</code> are represented as <code>CrespiValue</code> until   specialized in codegen.</li> <li>Pointer-typed <code>T?</code> may use null pointers only when the type is explicitly   nullable; otherwise nulls are boxed.</li> </ul>"},{"location":"llvm/abi/#runtime-helper-abi","title":"Runtime Helper ABI","text":"<ul> <li>Pure numeric helpers are plain C ABI functions (no <code>gc_ctx</code>), e.g.:   <code>crespi_rt_add_int(i64, i64) -&gt; i64</code>.</li> <li>LLVM codegen prefers typed helpers for <code>Int</code>/<code>Double</code> when type information   is available, and falls back to boxed helpers otherwise.</li> <li>Helpers that allocate (strings, lists, objects) take <code>gc_ctx</code> as the first   parameter.</li> <li>Closure creation uses <code>crespi_rt_make_closure(gc_ctx, code_ptr, captures_ptr,   capture_count, arity, min_arity, mutable_mask_ptr, mutable_mask_len,   name_ptr, name_len) -&gt; CrespiValue</code>. The mutable mask is a <code>u64</code> bitset   array; bit <code>i</code> marks capture <code>i</code> as mutable.</li> </ul>"},{"location":"llvm/abi/#notes","title":"Notes","text":"<ul> <li>This ABI is shared by <code>crespic</code> (LLVM backend) and <code>crespi-runtime</code>.</li> </ul>"}]}